export interface paths {
    "/apis": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract APIs that have been published */
        get: operations["getContractAPIs"];
        put?: never;
        /** @description Creates and broadcasts a new custom smart contract API */
        post: operations["postNewContractAPI"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apis/{apiName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets information about a contract API, including the URLs for the OpenAPI Spec and Swagger UI for the API */
        get: operations["getContractAPIByName"];
        /** @description The ID of the contract API */
        put: operations["putContractAPI"];
        post?: never;
        /** @description Delete a contract API */
        delete: operations["deleteContractAPI"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apis/{apiName}/interface": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract interface for a contract API */
        get: operations["getContractAPIInterface"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apis/{apiName}/invoke/{methodPath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Invokes a method on a smart contract API. Performs a blockchain transaction. */
        post: operations["postContractAPIInvoke"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apis/{apiName}/listeners/{eventPath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract listeners */
        get: operations["getContractAPIListeners"];
        put?: never;
        /** @description Creates a new blockchain listener for events emitted by custom smart contracts */
        post: operations["postContractAPIListeners"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apis/{apiName}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publish a contract API to all other members of the multiparty network */
        post: operations["postContractAPIPublish"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apis/{apiName}/query/{methodPath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Queries a method on a smart contract API. Performs a read-only query. */
        post: operations["postContractAPIQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of message batches */
        get: operations["getBatches"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batches/{batchid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a message batch */
        get: operations["getBatchByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batches/{batchid}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Cancel a batch that has failed to dispatch */
        post: operations["postBatchCancel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blockchainevents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of blockchain events */
        get: operations["getBlockchainEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blockchainevents/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a blockchain event */
        get: operations["getBlockchainEventByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/charts/histogram/{collection}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a JSON object containing statistics data that can be used to build a graphical representation of recent activity in a given database collection */
        get: operations["getChartHistogram"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/deploy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Deploy a new smart contract */
        post: operations["postContractDeploy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/interfaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract interfaces that have been published */
        get: operations["getContractInterfaces"];
        put?: never;
        /** @description Creates and broadcasts a new custom smart contract interface */
        post: operations["postNewContractInterface"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/interfaces/{interfaceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract interface by its ID */
        get: operations["getContractInterface"];
        put?: never;
        post?: never;
        /** @description Delete a contract interface */
        delete: operations["deleteContractInterface"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/interfaces/{name}/{version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract interface by its name and version */
        get: operations["getContractInterfaceByNameAndVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/interfaces/{name}/{version}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publish a contract interface to all other members of the multiparty network */
        post: operations["postContractInterfacePublish"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/interfaces/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description A convenience method to convert a blockchain specific smart contract format into a FireFly Interface format. The specific blockchain plugin in use must support this functionality. */
        post: operations["postGenerateContractInterface"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/invoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Invokes a method on a smart contract. Performs a blockchain transaction. */
        post: operations["postContractInvoke"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/listeners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract listeners */
        get: operations["getContractListeners"];
        put?: never;
        /** @description Creates a new blockchain listener for events emitted by custom smart contracts */
        post: operations["postNewContractListener"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/listeners/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract listener by its name or ID */
        get: operations["getContractListenerByNameOrID"];
        put?: never;
        post?: never;
        /** @description Deletes a contract listener referenced by its name or its ID */
        delete: operations["deleteContractListener"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/listeners/signature": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Calculates the hash of a blockchain listener filters and events */
        post: operations["postContractListenerSignature"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contracts/query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Queries a method on a smart contract. Performs a read-only query. */
        post: operations["postContractQuery"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of data items */
        get: operations["getData"];
        put?: never;
        /** @description Creates a new data item in this FireFly node */
        post: operations["postData"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{dataid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a data item by its ID, including metadata about this item */
        get: operations["getDataByID"];
        put?: never;
        post?: never;
        /** @description Deletes a data item by its ID, including metadata about this item */
        delete: operations["deleteData"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{dataid}/blob": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Downloads the original file that was previously uploaded or received */
        get: operations["getDataBlob"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{dataid}/blob/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publishes the binary blob attachment stored in your local data exchange, to shared storage */
        post: operations["postDataBlobPublish"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{dataid}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of the messages associated with a data item */
        get: operations["getDataMsgs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{dataid}/value": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Downloads the JSON value of the data resource, without the associated metadata */
        get: operations["getDataValue"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data/{dataid}/value/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publishes the JSON value from the specified data resource, to shared storage */
        post: operations["postDataValuePublish"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/datasubpaths/{parent}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of path names of named blob data, underneath a given parent path ('/' path prefixes are automatically pre-prepended) */
        get: operations["getDataSubPaths"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/datatypes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of datatypes that have been published */
        get: operations["getDatatypes"];
        put?: never;
        /** @description Creates and broadcasts a new datatype */
        post: operations["postNewDatatype"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/datatypes/{name}/{version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a datatype by its name and version */
        get: operations["getDatatypeByName"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of events */
        get: operations["getEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/events/{eid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets an event by its ID */
        get: operations["getEventByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of groups */
        get: operations["getGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/groups/{hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a group by its ID (hash) */
        get: operations["getGroupByHash"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of all identities that have been registered in the namespace */
        get: operations["getIdentities"];
        put?: never;
        /** @description Registers a new identity in the network */
        post: operations["postNewIdentity"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identities/{did}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets an identity by its ID */
        get: operations["getIdentityByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Updates an identity */
        patch: operations["patchUpdateIdentity"];
        trace?: never;
    };
    "/identities/{iid}/did": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the DID for an identity based on its ID */
        get: operations["getIdentityDID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/identities/{iid}/verifiers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the verifiers for an identity */
        get: operations["getIdentityVerifiers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of messages */
        get: operations["getMsgs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{msgid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a message by its ID */
        get: operations["getMsgByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{msgid}/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the list of data items that are attached to a message */
        get: operations["getMsgData"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{msgid}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the list of events for a message */
        get: operations["getMsgEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{msgid}/transaction": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the transaction for a message */
        get: operations["getMsgTxn"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/broadcast": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Broadcasts a message to all members in the network */
        post: operations["postNewMessageBroadcast"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/private": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Privately sends a message to one or more members in the network */
        post: operations["postNewMessagePrivate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/requestreply": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Sends a message with a blocking HTTP request, waits for a reply to that message, then sends the reply as the HTTP response. */
        post: operations["postNewMessageRequestReply"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of namespaces */
        get: operations["getNamespaces"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a namespace */
        get: operations["getNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/apis": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract APIs that have been published */
        get: operations["getContractAPIsNamespace"];
        put?: never;
        /** @description Creates and broadcasts a new custom smart contract API */
        post: operations["postNewContractAPINamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/apis/{apiName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets information about a contract API, including the URLs for the OpenAPI Spec and Swagger UI for the API */
        get: operations["getContractAPIByNameNamespace"];
        /** @description The ID of the contract API */
        put: operations["putContractAPINamespace"];
        post?: never;
        /** @description Delete a contract API */
        delete: operations["deleteContractAPINamespace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/apis/{apiName}/interface": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract interface for a contract API */
        get: operations["getContractAPIInterfaceNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/apis/{apiName}/invoke/{methodPath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Invokes a method on a smart contract API. Performs a blockchain transaction. */
        post: operations["postContractAPIInvokeNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/apis/{apiName}/listeners/{eventPath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract listeners */
        get: operations["getContractAPIListenersNamespace"];
        put?: never;
        /** @description Creates a new blockchain listener for events emitted by custom smart contracts */
        post: operations["postContractAPIListenersNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/apis/{apiName}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publish a contract API to all other members of the multiparty network */
        post: operations["postContractAPIPublishNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/apis/{apiName}/query/{methodPath}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Queries a method on a smart contract API. Performs a read-only query. */
        post: operations["postContractAPIQueryNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/batches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of message batches */
        get: operations["getBatchesNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/batches/{batchid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a message batch */
        get: operations["getBatchByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/batches/{batchid}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Cancel a batch that has failed to dispatch */
        post: operations["postBatchCancelNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/blockchainevents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of blockchain events */
        get: operations["getBlockchainEventsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/blockchainevents/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a blockchain event */
        get: operations["getBlockchainEventByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/charts/histogram/{collection}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a JSON object containing statistics data that can be used to build a graphical representation of recent activity in a given database collection */
        get: operations["getChartHistogramNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/deploy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Deploy a new smart contract */
        post: operations["postContractDeployNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/interfaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract interfaces that have been published */
        get: operations["getContractInterfacesNamespace"];
        put?: never;
        /** @description Creates and broadcasts a new custom smart contract interface */
        post: operations["postNewContractInterfaceNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/interfaces/{interfaceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract interface by its ID */
        get: operations["getContractInterfaceNamespace"];
        put?: never;
        post?: never;
        /** @description Delete a contract interface */
        delete: operations["deleteContractInterfaceNamespace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/interfaces/{name}/{version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract interface by its name and version */
        get: operations["getContractInterfaceByNameAndVersionNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/interfaces/{name}/{version}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publish a contract interface to all other members of the multiparty network */
        post: operations["postContractInterfacePublishNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/interfaces/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description A convenience method to convert a blockchain specific smart contract format into a FireFly Interface format. The specific blockchain plugin in use must support this functionality. */
        post: operations["postGenerateContractInterfaceNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/invoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Invokes a method on a smart contract. Performs a blockchain transaction. */
        post: operations["postContractInvokeNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/listeners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of contract listeners */
        get: operations["getContractListenersNamespace"];
        put?: never;
        /** @description Creates a new blockchain listener for events emitted by custom smart contracts */
        post: operations["postNewContractListenerNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/listeners/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a contract listener by its name or ID */
        get: operations["getContractListenerByNameOrIDNamespace"];
        put?: never;
        post?: never;
        /** @description Deletes a contract listener referenced by its name or its ID */
        delete: operations["deleteContractListenerNamespace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/listeners/signature": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Calculates the hash of a blockchain listener filters and events */
        post: operations["postContractListenerSignatureNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/contracts/query": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Queries a method on a smart contract. Performs a read-only query. */
        post: operations["postContractQueryNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of data items */
        get: operations["getDataNamespace"];
        put?: never;
        /** @description Creates a new data item in this FireFly node */
        post: operations["postDataNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/data/{dataid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a data item by its ID, including metadata about this item */
        get: operations["getDataByIDNamespace"];
        put?: never;
        post?: never;
        /** @description Deletes a data item by its ID, including metadata about this item */
        delete: operations["deleteDataNamespace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/data/{dataid}/blob": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Downloads the original file that was previously uploaded or received */
        get: operations["getDataBlobNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/data/{dataid}/blob/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publishes the binary blob attachment stored in your local data exchange, to shared storage */
        post: operations["postDataBlobPublishNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/data/{dataid}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of the messages associated with a data item */
        get: operations["getDataMsgsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/data/{dataid}/value": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Downloads the JSON value of the data resource, without the associated metadata */
        get: operations["getDataValueNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/data/{dataid}/value/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publishes the JSON value from the specified data resource, to shared storage */
        post: operations["postDataValuePublishNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/datasubpaths/{parent}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of path names of named blob data, underneath a given parent path ('/' path prefixes are automatically pre-prepended) */
        get: operations["getDataSubPathsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/datatypes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of datatypes that have been published */
        get: operations["getDatatypesNamespace"];
        put?: never;
        /** @description Creates and broadcasts a new datatype */
        post: operations["postNewDatatypeNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/datatypes/{name}/{version}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a datatype by its name and version */
        get: operations["getDatatypeByNameNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of events */
        get: operations["getEventsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/events/{eid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets an event by its ID */
        get: operations["getEventByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of groups */
        get: operations["getGroupsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/groups/{hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a group by its ID (hash) */
        get: operations["getGroupByHashNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/identities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of all identities that have been registered in the namespace */
        get: operations["getIdentitiesNamespace"];
        put?: never;
        /** @description Registers a new identity in the network */
        post: operations["postNewIdentityNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/identities/{did}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets an identity by its ID */
        get: operations["getIdentityByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Updates an identity */
        patch: operations["patchUpdateIdentityNamespace"];
        trace?: never;
    };
    "/namespaces/{ns}/identities/{iid}/did": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the DID for an identity based on its ID */
        get: operations["getIdentityDIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/identities/{iid}/verifiers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the verifiers for an identity */
        get: operations["getIdentityVerifiersNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of messages */
        get: operations["getMsgsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages/{msgid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a message by its ID */
        get: operations["getMsgByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages/{msgid}/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the list of data items that are attached to a message */
        get: operations["getMsgDataNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages/{msgid}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the list of events for a message */
        get: operations["getMsgEventsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages/{msgid}/transaction": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the transaction for a message */
        get: operations["getMsgTxnNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages/broadcast": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Broadcasts a message to all members in the network */
        post: operations["postNewMessageBroadcastNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages/private": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Privately sends a message to one or more members in the network */
        post: operations["postNewMessagePrivateNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/messages/requestreply": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Sends a message with a blocking HTTP request, waits for a reply to that message, then sends the reply as the HTTP response. */
        post: operations["postNewMessageRequestReplyNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/action": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Notify all nodes in the network of a new governance action */
        post: operations["postNetworkActionNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/diddocs/{did}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a DID document by its DID */
        get: operations["getNetworkDIDDocByDIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/identities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @deprecated
         * @description Gets the list of identities in the network (deprecated - use /identities instead of /network/identities
         */
        get: operations["getNetworkIdentitiesNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/identities/{did}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @deprecated
         * @description Gets an identity by its DID
         */
        get: operations["getNetworkIdentityByDIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of nodes in the network */
        get: operations["getNetworkNodesNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/nodes/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets information about a specific node in the network */
        get: operations["getNetworkNodeNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/nodes/self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Instructs this FireFly node to register itself on the network */
        post: operations["postNodesSelfNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/organizations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of orgs in the network */
        get: operations["getNetworkOrgsNamespace"];
        put?: never;
        /** @description Registers a new org in the network */
        post: operations["postNewOrganizationNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/organizations/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets information about a specific org in the network */
        get: operations["getNetworkOrgNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/network/organizations/self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Instructs this FireFly node to register its org on the network */
        post: operations["postNewOrganizationSelfNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/nextpins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Queries the list of next-pins that determine the next masked message sequence for each member of a privacy group, on each context/topic */
        get: operations["getNextPinsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a a list of operations */
        get: operations["getOpsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/operations/{opid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets an operation by ID */
        get: operations["getOpByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/operations/{opid}/retry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Retries a failed operation */
        post: operations["postOpRetryNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/pins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Queries the list of pins received from the blockchain */
        get: operations["getPinsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/pins/rewind": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Force a rewind of the event aggregator to a previous position, to re-evaluate (and possibly dispatch) that pin and others after it. Only accepts a sequence or batch ID for a currently undispatched pin */
        post: operations["postPinsRewindNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the status of this namespace */
        get: operations["getStatusNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/status/batchmanager": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the status of the batch manager */
        get: operations["getStatusBatchManagerNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/status/multiparty": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the registration status of this organization and node on the configured multiparty network */
        get: operations["getStatusMultipartyNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of subscriptions */
        get: operations["getSubscriptionsNamespace"];
        /** @description Update an existing subscription */
        put: operations["putSubscriptionNamespace"];
        /** @description Creates a new subscription for an application to receive events from FireFly */
        post: operations["postNewSubscriptionNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/subscriptions/{subid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a subscription by its ID */
        get: operations["getSubscriptionByIDNamespace"];
        put?: never;
        post?: never;
        /** @description Deletes a subscription */
        delete: operations["deleteSubscriptionNamespace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/subscriptions/{subid}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a collection of events filtered by the subscription for further filtering */
        get: operations["getSubscriptionEventsFilteredNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/accounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token accounts */
        get: operations["getTokenAccountsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/accounts/{key}/pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token pools that contain a given token account key */
        get: operations["getTokenAccountPoolsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/approvals": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token approvals */
        get: operations["getTokenApprovalsNamespace"];
        put?: never;
        /** @description Creates a token approval */
        post: operations["postTokenApprovalNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/balances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token balances */
        get: operations["getTokenBalancesNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/burn": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Burns some tokens */
        post: operations["postTokenBurnNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/connectors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the list of token connectors currently in use */
        get: operations["getTokenConnectorsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/mint": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Mints some tokens */
        post: operations["postTokenMintNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token pools */
        get: operations["getTokenPoolsNamespace"];
        put?: never;
        /** @description Creates a new token pool */
        post: operations["postTokenPoolNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/pools/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a token pool by its name or its ID */
        get: operations["getTokenPoolByNameOrIDNamespace"];
        put?: never;
        post?: never;
        /** @description Delete a token pool */
        delete: operations["deleteTokenPoolNamespace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/pools/{nameOrId}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publish a token pool to all other members of the multiparty network */
        post: operations["postTokenPoolPublishNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/transfers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token transfers */
        get: operations["getTokenTransfersNamespace"];
        put?: never;
        /** @description Transfers some tokens */
        post: operations["postTokenTransferNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/tokens/transfers/{transferId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a token transfer by its ID */
        get: operations["getTokenTransferByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/transactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of transactions */
        get: operations["getTxnsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/transactions/{txnid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a transaction by its ID */
        get: operations["getTxnByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/transactions/{txnid}/blockchainevents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list blockchain events for a specific transaction */
        get: operations["getTxnBlockchainEventsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/transactions/{txnid}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of operations in a specific transaction */
        get: operations["getTxnOpsNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/transactions/{txnid}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the status of a transaction */
        get: operations["getTxnStatusNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/verifiers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of verifiers */
        get: operations["getVerifiersNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/verifiers/{hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a verifier by its hash */
        get: operations["getVerifierByIDNamespace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/namespaces/{ns}/verifiers/resolve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Resolves an input key to a signing key */
        post: operations["postVerifiersResolveNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/action": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Notify all nodes in the network of a new governance action */
        post: operations["postNetworkAction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/diddocs/{did}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a DID document by its DID */
        get: operations["getNetworkDIDDocByDID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/identities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @deprecated
         * @description Gets the list of identities in the network (deprecated - use /identities instead of /network/identities
         */
        get: operations["getNetworkIdentities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/identities/{did}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @deprecated
         * @description Gets an identity by its DID
         */
        get: operations["getNetworkIdentityByDID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of nodes in the network */
        get: operations["getNetworkNodes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/nodes/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets information about a specific node in the network */
        get: operations["getNetworkNode"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/nodes/self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Instructs this FireFly node to register itself on the network */
        post: operations["postNodesSelf"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/organizations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of orgs in the network */
        get: operations["getNetworkOrgs"];
        put?: never;
        /** @description Registers a new org in the network */
        post: operations["postNewOrganization"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/organizations/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets information about a specific org in the network */
        get: operations["getNetworkOrg"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/network/organizations/self": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Instructs this FireFly node to register its org on the network */
        post: operations["postNewOrganizationSelf"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nextpins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Queries the list of next-pins that determine the next masked message sequence for each member of a privacy group, on each context/topic */
        get: operations["getNextPins"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a a list of operations */
        get: operations["getOps"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/operations/{opid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets an operation by ID */
        get: operations["getOpByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/operations/{opid}/retry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Retries a failed operation */
        post: operations["postOpRetry"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Queries the list of pins received from the blockchain */
        get: operations["getPins"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pins/rewind": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Force a rewind of the event aggregator to a previous position, to re-evaluate (and possibly dispatch) that pin and others after it. Only accepts a sequence or batch ID for a currently undispatched pin */
        post: operations["postPinsRewind"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the status of this namespace */
        get: operations["getStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/batchmanager": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the status of the batch manager */
        get: operations["getStatusBatchManager"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/multiparty": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the registration status of this organization and node on the configured multiparty network */
        get: operations["getStatusMultiparty"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of subscriptions */
        get: operations["getSubscriptions"];
        /** @description Update an existing subscription */
        put: operations["putSubscription"];
        /** @description Creates a new subscription for an application to receive events from FireFly */
        post: operations["postNewSubscription"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/subscriptions/{subid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a subscription by its ID */
        get: operations["getSubscriptionByID"];
        put?: never;
        post?: never;
        /** @description Deletes a subscription */
        delete: operations["deleteSubscription"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/subscriptions/{subid}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a collection of events filtered by the subscription for further filtering */
        get: operations["getSubscriptionEventsFiltered"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/accounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token accounts */
        get: operations["getTokenAccounts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/accounts/{key}/pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token pools that contain a given token account key */
        get: operations["getTokenAccountPools"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/approvals": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token approvals */
        get: operations["getTokenApprovals"];
        put?: never;
        /** @description Creates a token approval */
        post: operations["postTokenApproval"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/balances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token balances */
        get: operations["getTokenBalances"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/burn": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Burns some tokens */
        post: operations["postTokenBurn"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/connectors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the list of token connectors currently in use */
        get: operations["getTokenConnectors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/mint": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Mints some tokens */
        post: operations["postTokenMint"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/pools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token pools */
        get: operations["getTokenPools"];
        put?: never;
        /** @description Creates a new token pool */
        post: operations["postTokenPool"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/pools/{nameOrId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a token pool by its name or its ID */
        get: operations["getTokenPoolByNameOrID"];
        put?: never;
        post?: never;
        /** @description Delete a token pool */
        delete: operations["deleteTokenPool"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/pools/{nameOrId}/publish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Publish a token pool to all other members of the multiparty network */
        post: operations["postTokenPoolPublish"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/transfers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of token transfers */
        get: operations["getTokenTransfers"];
        put?: never;
        /** @description Transfers some tokens */
        post: operations["postTokenTransfer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/transfers/{transferId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a token transfer by its ID */
        get: operations["getTokenTransferByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transactions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of transactions */
        get: operations["getTxns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transactions/{txnid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a transaction by its ID */
        get: operations["getTxnByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transactions/{txnid}/blockchainevents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list blockchain events for a specific transaction */
        get: operations["getTxnBlockchainEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transactions/{txnid}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of operations in a specific transaction */
        get: operations["getTxnOps"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/transactions/{txnid}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the status of a transaction */
        get: operations["getTxnStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/verifiers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of verifiers */
        get: operations["getVerifiers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/verifiers/{hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a verifier by its hash */
        get: operations["getVerifierByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/verifiers/resolve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Resolves an input key to a signing key */
        post: operations["postVerifiersResolve"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/websockets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a list of the current WebSocket connections to this node */
        get: operations["getWebSockets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: never;
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getContractAPIs: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                networkname?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                published?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewContractAPI: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
                /** @description When true the definition will be published to all other members of the multiparty network */
                publish?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Reference to the FireFly Interface definition associated with the contract API */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description The name that is used in the URL to access the API */
                    name?: string;
                    /** @description The published name of the API within the multiparty network */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractAPIByName: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putContractAPI: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Reference to the FireFly Interface definition associated with the contract API */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description The name that is used in the URL to access the API */
                    name?: string;
                    /** @description The published name of the API within the multiparty network */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteContractAPI: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractAPIInterface: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIInvoke: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a method on a smart contract */
                methodPath: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractAPIListeners: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                backendid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                filters?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                location?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                signature?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a event on a smart contract */
                eventPath: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIListeners: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a event on a smart contract */
                eventPath: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                    event?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                    location?: any;
                    /** @description A descriptive name for the listener */
                    name?: string;
                    /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                    options?: {
                        /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                        firstEvent?: string;
                    } | null;
                    /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                    topic?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string | null;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string | null;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIPublish: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIQuery: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a method on a smart contract */
                methodPath: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": any;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBatches: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                node?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                payloadref?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: date-time
                         * @description The time when the batch was confirmed
                         */
                        confirmed?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the batch was sealed
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The privacy group the batch is sent to, for private batches
                         */
                        group?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the manifest of the batch
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the batch
                         */
                        id?: string;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The manifest of the batch */
                        manifest?: any;
                        /** @description The namespace of the batch */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the node that generated the batch
                         */
                        node?: string | null;
                        /** @description The FireFly transaction associated with this batch */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of the batch
                         * @enum {string}
                         */
                        type?: "broadcast" | "private";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBatchByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The batch ID */
                batchid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: date-time
                         * @description The time when the batch was confirmed
                         */
                        confirmed?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the batch was sealed
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The privacy group the batch is sent to, for private batches
                         */
                        group?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the manifest of the batch
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the batch
                         */
                        id?: string;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The manifest of the batch */
                        manifest?: any;
                        /** @description The namespace of the batch */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the node that generated the batch
                         */
                        node?: string | null;
                        /** @description The FireFly transaction associated with this batch */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of the batch
                         * @enum {string}
                         */
                        type?: "broadcast" | "private";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postBatchCancel: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The batch ID */
                batchid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": unknown;
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlockchainEvents: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                listener?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                protocolid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                source?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                timestamp?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.blockchainid"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID assigned to the event by FireFly
                         */
                        id?: string;
                        /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
                        info?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
                         */
                        listener?: string | null;
                        /** @description The name of the event in the blockchain smart contract */
                        name?: string;
                        /** @description The namespace of the listener that detected this blockchain event */
                        namespace?: string;
                        /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
                        output?: any;
                        /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
                        protocolId?: string;
                        /** @description The blockchain plugin or token service that detected the event */
                        source?: string;
                        /**
                         * Format: date-time
                         * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
                         */
                        timestamp?: string | null;
                        /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
                        tx?: {
                            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
                            blockchainId?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlockchainEventByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blockchain event ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID assigned to the event by FireFly
                         */
                        id?: string;
                        /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
                        info?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
                         */
                        listener?: string | null;
                        /** @description The name of the event in the blockchain smart contract */
                        name?: string;
                        /** @description The namespace of the listener that detected this blockchain event */
                        namespace?: string;
                        /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
                        output?: any;
                        /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
                        protocolId?: string;
                        /** @description The blockchain plugin or token service that detected the event */
                        source?: string;
                        /**
                         * Format: date-time
                         * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
                         */
                        timestamp?: string | null;
                        /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
                        tx?: {
                            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
                            blockchainId?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getChartHistogram: {
        parameters: {
            query?: {
                /** @description Start time of the data to be fetched */
                startTime?: string;
                /** @description End time of the data to be fetched */
                endTime?: string;
                /** @description Number of buckets between start time and end time */
                buckets?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The collection ID */
                collection: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total count of entries in this time bucket within the histogram */
                        count?: string;
                        /** @description Indicates whether there are more results in this bucket that are not being displayed */
                        isCapped?: boolean;
                        /**
                         * Format: date-time
                         * @description Starting timestamp for the bucket
                         */
                        timestamp?: string | null;
                        /** @description Array of separate counts for individual types of record within the bucket */
                        types?: {
                            /** @description Count of entries of a given type within a bucket */
                            count?: string;
                            /** @description Name of the type */
                            type?: string;
                        }[];
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractDeploy: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The smart contract to deploy. This should be pre-compiled if required by the blockchain connector */
                    contract?: any;
                    /** @description The definition of the smart contract */
                    definition?: any;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description An optional array of inputs passed to the smart contract's constructor, if applicable */
                    input?: unknown[];
                    /** @description The blockchain signing key that will be used to deploy the contract. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractInterfaces: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                networkname?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                published?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                version?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewContractInterface: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
                /** @description When true the definition will be published to all other members of the multiparty network */
                publish?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the smart contract this FFI represents */
                    description?: string;
                    /** @description An array of smart contract error definitions */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An array of smart contract event definitions */
                    events?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An array of smart contract method definitions */
                    methods?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description The name of the FFI - usually matching the smart contract name */
                    name?: string;
                    /** @description The published name of the FFI within the multiparty network */
                    networkName?: string;
                    /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                    version?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractInterface: {
        parameters: {
            query?: {
                /** @description When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
                fetchchildren?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The ID of the contract interface */
                interfaceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteContractInterface: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The ID of the contract interface */
                interfaceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractInterfaceByNameAndVersion: {
        parameters: {
            query?: {
                /** @description When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
                fetchchildren?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract interface */
                name: string;
                /** @description The version of the contract interface */
                version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractInterfacePublish: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract interface */
                name: string;
                /** @description The version of the contract interface */
                version: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postGenerateContractInterface: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The description of the FFI to be generated. Defaults to the description extracted by the blockchain specific converter utility */
                    description?: string;
                    /** @description A blockchain connector specific payload. For example in Ethereum this is a JSON structure containing an 'abi' array, and optionally a 'devdocs' array. */
                    input?: any;
                    /** @description The name of the FFI to generate */
                    name?: string;
                    /** @description The namespace into which the FFI will be generated */
                    namespace?: string;
                    /** @description The version of the FFI to generate */
                    version?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractInvoke: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the blockchain transaction is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /**
                     * Format: uuid
                     * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
                     */
                    interface?: string | null;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
                    method?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description The pathname of the method on the specified FFI */
                    methodPath?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractListeners: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                backendid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                filters?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                location?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                signature?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewContractListener: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                    event?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description Deprecated: Please use 'eventPath' in the array of 'filters' instead */
                    eventPath?: string;
                    /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                    filters?: {
                        /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description When creating a listener from an existing FFI, this is the pathname of the event on that FFI to be detected by this listener */
                        eventPath?: string;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                    }[];
                    /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                    location?: any;
                    /** @description A descriptive name for the listener */
                    name?: string;
                    /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                    options?: {
                        /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                        firstEvent?: string;
                    } | null;
                    /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                    topic?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string | null;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string | null;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractListenerByNameOrID: {
        parameters: {
            query?: {
                /** @description When set, the API will return additional status information if available */
                fetchstatus?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The contract listener name or ID */
                nameOrId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteContractListener: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The contract listener name or ID */
                nameOrId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractListenerSignature: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                    event?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description Deprecated: Please use 'eventPath' in the array of 'filters' instead */
                    eventPath?: string;
                    /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                    filters?: {
                        /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description When creating a listener from an existing FFI, this is the pathname of the event on that FFI to be detected by this listener */
                        eventPath?: string;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                    }[];
                    /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                    location?: any;
                    /** @description A descriptive name for the listener */
                    name?: string;
                    /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                    options?: {
                        /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                        firstEvent?: string;
                    } | null;
                    /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                    topic?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractQuery: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /**
                     * Format: uuid
                     * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
                     */
                    interface?: string | null;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
                    method?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description The pathname of the method on the specified FFI */
                    methodPath?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": any;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getData: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.hash"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.name"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.path"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.public"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.size"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "datatype.name"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "datatype.version"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                public?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                validator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                value?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postData: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The optional datatype to use for validation of the in-line data */
                    datatype?: {
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                        version?: string;
                    } | null;
                    /**
                     * Format: uuid
                     * @description The UUID of the referenced data resource
                     */
                    id?: string | null;
                    /** @description The data validator type to use for in-line data */
                    validator?: string;
                    /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                    value?: any;
                };
                "multipart/form-data": {
                    /** @description Success */
                    autometa?: string;
                    /** @description Success */
                    "datatype.name"?: string;
                    /** @description Success */
                    "datatype.version"?: string;
                    /** Format: binary */
                    "filename.ext"?: string;
                    /** @description Success */
                    metadata?: string;
                    /** @description Success */
                    validator?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string | null;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteData: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataBlob: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postDataBlobPublish: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blob ID */
                dataid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string | null;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataMsgs: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataValue: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blob ID */
                dataid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postDataValuePublish: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blob ID */
                dataid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string | null;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataSubPaths: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The parent path to query */
                parent: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatatypes: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                validator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                version?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewDatatype: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The name of the datatype */
                    name?: string;
                    /**
                     * @description The validator that should be used to verify this datatype
                     * @enum {string}
                     */
                    validator?: "json" | "none" | "definition";
                    /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                    value?: any;
                    /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                    version?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatatypeByName: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the datatype */
                name: string;
                /** @description The version of the datatype */
                version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getEvents: {
        parameters: {
            query?: {
                /** @description When set, the API will return the record that this item references in its 'reference' field */
                fetchreferences?: string;
                /** @description When set, the API will return the record that this item references in its 'reference' field */
                fetchreference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                correlator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                reference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getEventByID: {
        parameters: {
            query?: {
                /** @description When set, the API will return the record that this item references in its 'reference' field */
                fetchreference?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The event ID */
                eid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getGroups: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                ledger?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time when the group was first used to send a message in the network
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The identifier hash of this group. Derived from the name and group members
                         */
                        hash?: string | null;
                        /** @description The local namespace of the group */
                        localNamespace?: string;
                        /** @description The list of members in this privacy group */
                        members?: {
                            /** @description The DID of the group member */
                            identity?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the node that receives a copy of the off-chain message for the identity
                             */
                            node?: string | null;
                        }[];
                        /**
                         * Format: uuid
                         * @description The message used to broadcast this group privately to the members
                         */
                        message?: string | null;
                        /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
                        name?: string;
                        /** @description The namespace of the group within the multiparty network */
                        namespace?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getGroupByHash: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The hash of the group */
                hash: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time when the group was first used to send a message in the network
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The identifier hash of this group. Derived from the name and group members
                         */
                        hash?: string | null;
                        /** @description The local namespace of the group */
                        localNamespace?: string;
                        /** @description The list of members in this privacy group */
                        members?: {
                            /** @description The DID of the group member */
                            identity?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the node that receives a copy of the off-chain message for the identity
                             */
                            node?: string | null;
                        }[];
                        /**
                         * Format: uuid
                         * @description The message used to broadcast this group privately to the members
                         */
                        message?: string | null;
                        /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
                        name?: string;
                        /** @description The namespace of the group within the multiparty network */
                        namespace?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentities: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                        /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
                        verifiers?: {
                            /**
                             * @description The type of the verifier
                             * @enum {string}
                             */
                            type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                            value?: string;
                        }[];
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewIdentity: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the identity. Part of the updatable profile information of an identity */
                    description?: string;
                    /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
                    key?: string;
                    /** @description The name of the identity. The name must be unique within the type and namespace */
                    name?: string;
                    /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
                    parent?: string;
                    /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                    profile?: any;
                    /** @description The type of the identity */
                    type?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentityByID: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    patchUpdateIdentity: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the identity. Part of the updatable profile information of an identity */
                    description?: string;
                    /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                    profile?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentityDID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description See https://www.w3.org/TR/did-core/#json-ld */
                        "@context"?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        authentication?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        id?: string;
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        verificationMethod?: {
                            /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
                            blockchainAcountId?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            controller?: string;
                            /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
                            dataExchangePeerID?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            id?: string;
                            /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
                            mspIdentityString?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            type?: string;
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentityVerifiers: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                identity?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                value?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time this verifier was created on this node
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity that has claimed this verifier
                         */
                        identity?: string | null;
                        /** @description The namespace of the verifier */
                        namespace?: string;
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgs: {
        parameters: {
            query?: {
                /** @description Fetch the data and include it in the messages returned */
                fetchdata?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgByID: {
        parameters: {
            query?: {
                /** @description Fetch the data and include it in the messages returned */
                fetchdata?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description An optional in-line hash reference to a previously uploaded binary data blob */
                            blob?: {
                                /**
                                 * Format: byte
                                 * @description The hash of the binary blob data
                                 */
                                hash?: string | null;
                                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                                name?: string;
                                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                                path?: string;
                                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                                public?: string;
                                /**
                                 * Format: int64
                                 * @description The size of the binary data
                                 */
                                size?: number;
                            } | null;
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgData: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgEvents: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                correlator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                reference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgTxn: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
                        blockchainIds?: string[];
                        /**
                         * Format: date-time
                         * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction
                         */
                        id?: string;
                        /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
                        idempotencyKey?: string;
                        /** @description The namespace of the FireFly transaction */
                        namespace?: string;
                        /**
                         * @description The type of the FireFly transaction
                         * @enum {string}
                         */
                        type?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewMessageBroadcast: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                    data?: {
                        /** @description The optional datatype to use for validation of the in-line data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the referenced data resource
                         */
                        id?: string | null;
                        /** @description The data validator type to use for in-line data */
                        validator?: string;
                        /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                        value?: any;
                    }[];
                    /** @description The message header contains all fields that are used to build the message hash */
                    header?: {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: uuid
                         * @description The correlation ID of the message. Set this when a message is a response to another message
                         */
                        cid?: string | null;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The message tag indicates the purpose of the message to the applications that process it */
                        tag?: string;
                        /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                        topics?: string[];
                        /**
                         * @description The type of transaction used to order/deliver this message
                         * @enum {string}
                         */
                        txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                        /**
                         * @description The type of the message
                         * @enum {string}
                         */
                        type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                    };
                    /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewMessagePrivate: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                    data?: {
                        /** @description The optional datatype to use for validation of the in-line data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the referenced data resource
                         */
                        id?: string | null;
                        /** @description The data validator type to use for in-line data */
                        validator?: string;
                        /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                        value?: any;
                    }[];
                    /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                    group?: {
                        /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                        members?: {
                            /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                            identity?: string;
                            /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                            node?: string;
                        }[];
                        /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                        name?: string;
                    } | null;
                    /** @description The message header contains all fields that are used to build the message hash */
                    header?: {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: uuid
                         * @description The correlation ID of the message. Set this when a message is a response to another message
                         */
                        cid?: string | null;
                        /**
                         * Format: byte
                         * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                         */
                        group?: string | null;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The message tag indicates the purpose of the message to the applications that process it */
                        tag?: string;
                        /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                        topics?: string[];
                        /**
                         * @description The type of transaction used to order/deliver this message
                         * @enum {string}
                         */
                        txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                        /**
                         * @description The type of the message
                         * @enum {string}
                         */
                        type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                    };
                    /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewMessageRequestReply: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                    data?: {
                        /** @description The optional datatype to use for validation of the in-line data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the referenced data resource
                         */
                        id?: string | null;
                        /** @description The data validator type to use for in-line data */
                        validator?: string;
                        /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                        value?: any;
                    }[];
                    /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                    group?: {
                        /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                        members?: {
                            /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                            identity?: string;
                            /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                            node?: string;
                        }[];
                        /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                        name?: string;
                    } | null;
                    /** @description The message header contains all fields that are used to build the message hash */
                    header?: {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: uuid
                         * @description The correlation ID of the message. Set this when a message is a response to another message
                         */
                        cid?: string | null;
                        /**
                         * Format: byte
                         * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                         */
                        group?: string | null;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The message tag indicates the purpose of the message to the applications that process it */
                        tag?: string;
                        /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                        topics?: string[];
                        /**
                         * @description The type of transaction used to order/deliver this message
                         * @enum {string}
                         */
                        txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                        /**
                         * @description The type of the message
                         * @enum {string}
                         */
                        type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                    };
                    /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description An optional in-line hash reference to a previously uploaded binary data blob */
                            blob?: {
                                /**
                                 * Format: byte
                                 * @description The hash of the binary blob data
                                 */
                                hash?: string | null;
                                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                                name?: string;
                                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                                path?: string;
                                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                                public?: string;
                                /**
                                 * Format: int64
                                 * @description The size of the binary data
                                 */
                                size?: number;
                            } | null;
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNamespaces: {
        parameters: {
            query?: {
                /** @description When set, the API will return namespaces even if they are not yet initialized, including in error cases where an initializationError is included */
                includeinitializing?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the namespace was created
                         */
                        created?: string | null;
                        /** @description A description of the namespace */
                        description?: string;
                        /** @description Set to a non-empty string in the case that the namespace is currently failing to initialize */
                        initializationError?: string;
                        /** @description Set to true if the namespace is still initializing */
                        initializing?: boolean;
                        /** @description The local namespace name */
                        name?: string;
                        /** @description The shared namespace name within the multiparty network */
                        networkName?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the namespace was created
                         */
                        created?: string | null;
                        /** @description A description of the namespace */
                        description?: string;
                        /** @description The local namespace name */
                        name?: string;
                        /** @description The shared namespace name within the multiparty network */
                        networkName?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractAPIsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                networkname?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                published?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewContractAPINamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
                /** @description When true the definition will be published to all other members of the multiparty network */
                publish?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Reference to the FireFly Interface definition associated with the contract API */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description The name that is used in the URL to access the API */
                    name?: string;
                    /** @description The published name of the API within the multiparty network */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractAPIByNameNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putContractAPINamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                id: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Reference to the FireFly Interface definition associated with the contract API */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description The name that is used in the URL to access the API */
                    name?: string;
                    /** @description The published name of the API within the multiparty network */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the contract API
                         */
                        id?: string | null;
                        /** @description Reference to the FireFly Interface definition associated with the contract API */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this API to the network
                         */
                        message?: string | null;
                        /** @description The name that is used in the URL to access the API */
                        name?: string;
                        /** @description The namespace of the contract API */
                        namespace?: string;
                        /** @description The published name of the API within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the API is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The URLs to use to access the API */
                        urls?: {
                            /** @description The URL to use to invoke the API */
                            api?: string;
                            /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
                            openapi?: string;
                            /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
                            ui?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteContractAPINamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractAPIInterfaceNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIInvokeNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a method on a smart contract */
                methodPath: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /**
                     * Format: uuid
                     * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
                     */
                    interface?: string | null;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
                    method?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description The pathname of the method on the specified FFI */
                    methodPath?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractAPIListenersNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                backendid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                filters?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                location?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                signature?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a event on a smart contract */
                eventPath: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIListenersNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a event on a smart contract */
                eventPath: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                    event?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                    filters?: {
                        /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                    }[];
                    /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                    location?: any;
                    /** @description A descriptive name for the listener */
                    name?: string;
                    /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                    options?: {
                        /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                        firstEvent?: string;
                    } | null;
                    /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                    topic?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string | null;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string | null;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIPublishNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractAPIQueryNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract API */
                apiName: string;
                /** @description The name or uniquely generated path name of a method on a smart contract */
                methodPath: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /**
                     * Format: uuid
                     * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
                     */
                    interface?: string | null;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
                    method?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description The pathname of the method on the specified FFI */
                    methodPath?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": any;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBatchesNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                node?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                payloadref?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: date-time
                         * @description The time when the batch was confirmed
                         */
                        confirmed?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the batch was sealed
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The privacy group the batch is sent to, for private batches
                         */
                        group?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the manifest of the batch
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the batch
                         */
                        id?: string;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The manifest of the batch */
                        manifest?: any;
                        /** @description The namespace of the batch */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the node that generated the batch
                         */
                        node?: string | null;
                        /** @description The FireFly transaction associated with this batch */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of the batch
                         * @enum {string}
                         */
                        type?: "broadcast" | "private";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBatchByIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The batch ID */
                batchid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: date-time
                         * @description The time when the batch was confirmed
                         */
                        confirmed?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the batch was sealed
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The privacy group the batch is sent to, for private batches
                         */
                        group?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the manifest of the batch
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the batch
                         */
                        id?: string;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The manifest of the batch */
                        manifest?: any;
                        /** @description The namespace of the batch */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the node that generated the batch
                         */
                        node?: string | null;
                        /** @description The FireFly transaction associated with this batch */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of the batch
                         * @enum {string}
                         */
                        type?: "broadcast" | "private";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postBatchCancelNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The batch ID */
                batchid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": unknown;
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlockchainEventsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                listener?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                protocolid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                source?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                timestamp?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.blockchainid"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID assigned to the event by FireFly
                         */
                        id?: string;
                        /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
                        info?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
                         */
                        listener?: string | null;
                        /** @description The name of the event in the blockchain smart contract */
                        name?: string;
                        /** @description The namespace of the listener that detected this blockchain event */
                        namespace?: string;
                        /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
                        output?: any;
                        /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
                        protocolId?: string;
                        /** @description The blockchain plugin or token service that detected the event */
                        source?: string;
                        /**
                         * Format: date-time
                         * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
                         */
                        timestamp?: string | null;
                        /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
                        tx?: {
                            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
                            blockchainId?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlockchainEventByIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blockchain event ID */
                id: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID assigned to the event by FireFly
                         */
                        id?: string;
                        /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
                        info?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
                         */
                        listener?: string | null;
                        /** @description The name of the event in the blockchain smart contract */
                        name?: string;
                        /** @description The namespace of the listener that detected this blockchain event */
                        namespace?: string;
                        /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
                        output?: any;
                        /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
                        protocolId?: string;
                        /** @description The blockchain plugin or token service that detected the event */
                        source?: string;
                        /**
                         * Format: date-time
                         * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
                         */
                        timestamp?: string | null;
                        /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
                        tx?: {
                            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
                            blockchainId?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getChartHistogramNamespace: {
        parameters: {
            query?: {
                /** @description Start time of the data to be fetched */
                startTime?: string;
                /** @description End time of the data to be fetched */
                endTime?: string;
                /** @description Number of buckets between start time and end time */
                buckets?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The collection ID */
                collection: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total count of entries in this time bucket within the histogram */
                        count?: string;
                        /** @description Indicates whether there are more results in this bucket that are not being displayed */
                        isCapped?: boolean;
                        /**
                         * Format: date-time
                         * @description Starting timestamp for the bucket
                         */
                        timestamp?: string | null;
                        /** @description Array of separate counts for individual types of record within the bucket */
                        types?: {
                            /** @description Count of entries of a given type within a bucket */
                            count?: string;
                            /** @description Name of the type */
                            type?: string;
                        }[];
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractDeployNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The smart contract to deploy. This should be pre-compiled if required by the blockchain connector */
                    contract?: any;
                    /** @description The definition of the smart contract */
                    definition?: any;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description An optional array of inputs passed to the smart contract's constructor, if applicable */
                    input?: unknown[];
                    /** @description The blockchain signing key that will be used to deploy the contract. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractInterfacesNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                networkname?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                published?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                version?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewContractInterfaceNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
                /** @description When true the definition will be published to all other members of the multiparty network */
                publish?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the smart contract this FFI represents */
                    description?: string;
                    /** @description An array of smart contract error definitions */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An array of smart contract event definitions */
                    events?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An array of smart contract method definitions */
                    methods?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description The name of the FFI - usually matching the smart contract name */
                    name?: string;
                    /** @description The published name of the FFI within the multiparty network */
                    networkName?: string;
                    /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                    version?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractInterfaceNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
                fetchchildren?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The ID of the contract interface */
                interfaceId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteContractInterfaceNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The ID of the contract interface */
                interfaceId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractInterfaceByNameAndVersionNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
                fetchchildren?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract interface */
                name: string;
                /** @description The version of the contract interface */
                version: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractInterfacePublishNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the contract interface */
                name: string;
                /** @description The version of the contract interface */
                version: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postGenerateContractInterfaceNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The description of the FFI to be generated. Defaults to the description extracted by the blockchain specific converter utility */
                    description?: string;
                    /** @description A blockchain connector specific payload. For example in Ethereum this is a JSON structure containing an 'abi' array, and optionally a 'devdocs' array. */
                    input?: any;
                    /** @description The name of the FFI to generate */
                    name?: string;
                    /** @description The namespace into which the FFI will be generated */
                    namespace?: string;
                    /** @description The version of the FFI to generate */
                    version?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A description of the smart contract this FFI represents */
                        description?: string;
                        /** @description An array of smart contract error definitions */
                        errors?: {
                            /** @description A description of the smart contract error */
                            description?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI error definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this error is part of
                             */
                            interface?: string | null;
                            /** @description The name of the error */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of error parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this error within the FFI for use on URL paths */
                            pathname?: string;
                            /** @description The stringified signature of the error, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /** @description An array of smart contract event definitions */
                        events?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI event definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this event is part of
                             */
                            interface?: string | null;
                            /** @description The name of the event */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
                            pathname?: string;
                            /** @description The stringified signature of the event, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface (FFI) smart contract definition
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this FFI to the network
                         */
                        message?: string | null;
                        /** @description An array of smart contract method definitions */
                        methods?: {
                            /** @description A description of the smart contract method */
                            description?: string;
                            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI method definition
                             */
                            id?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the FFI smart contract definition that this method is part of
                             */
                            interface?: string | null;
                            /** @description The name of the method */
                            name?: string;
                            /** @description The namespace of the FFI */
                            namespace?: string;
                            /** @description An array of method parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                            /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
                            pathname?: string;
                            /** @description An array of method return definitions */
                            returns?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        }[];
                        /** @description The name of the FFI - usually matching the smart contract name */
                        name?: string;
                        /** @description The namespace of the FFI */
                        namespace?: string;
                        /** @description The published name of the FFI within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the FFI is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractInvokeNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the blockchain transaction is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /**
                     * Format: uuid
                     * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
                     */
                    interface?: string | null;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
                    method?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description The pathname of the method on the specified FFI */
                    methodPath?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractListenersNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                backendid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                filters?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                location?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                signature?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewContractListenerNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                    event?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description Deprecated: Please use 'eventPath' in the array of 'filters' instead */
                    eventPath?: string;
                    /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                    filters?: {
                        /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description When creating a listener from an existing FFI, this is the pathname of the event on that FFI to be detected by this listener */
                        eventPath?: string;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                    }[];
                    /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                    location?: any;
                    /** @description A descriptive name for the listener */
                    name?: string;
                    /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                    options?: {
                        /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                        firstEvent?: string;
                    } | null;
                    /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                    topic?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string | null;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string | null;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getContractListenerByNameOrIDNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return additional status information if available */
                fetchstatus?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The contract listener name or ID */
                nameOrId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An ID assigned by the blockchain connector to this listener */
                        backendId?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the listener
                         */
                        created?: string | null;
                        /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                        filters?: {
                            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                            event?: {
                                /** @description A description of the smart contract event */
                                description?: string;
                                /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                                details?: any;
                                /** @description The name of the event */
                                name?: string;
                                /** @description An array of event parameter/argument definitions */
                                params?: {
                                    /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                    name?: string;
                                    /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                    schema?: any;
                                }[];
                            } | null;
                            /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                            interface?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly interface
                                 */
                                id?: string;
                                /** @description The name of the FireFly interface */
                                name?: string;
                                /** @description The version of the FireFly interface */
                                version?: string;
                            } | null;
                            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                            location?: any;
                            /** @description The stringified signature of the event and location, as computed by the blockchain plugin */
                            signature?: string;
                        }[];
                        /**
                         * Format: uuid
                         * @description The UUID of the smart contract listener
                         */
                        id?: string;
                        /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                        location?: any;
                        /** @description A descriptive name for the listener */
                        name?: string;
                        /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
                        namespace?: string;
                        /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                        options?: {
                            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                            firstEvent?: string;
                        } | null;
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                        /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                        topic?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteContractListenerNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The contract listener name or ID */
                nameOrId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractListenerSignatureNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Deprecated: Please use 'event' in the array of 'filters' instead */
                    event?: {
                        /** @description A description of the smart contract event */
                        description?: string;
                        /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the event */
                        name?: string;
                        /** @description An array of event parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description Deprecated: Please use 'eventPath' in the array of 'filters' instead */
                    eventPath?: string;
                    /** @description A list of filters for the contract listener. Each filter is made up of an Event and an optional Location. Events matching these filters will always be emitted in the order determined by the blockchain. */
                    filters?: {
                        /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI when supplied */
                        event?: {
                            /** @description A description of the smart contract event */
                            description?: string;
                            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                            details?: any;
                            /** @description The name of the event */
                            name?: string;
                            /** @description An array of event parameter/argument definitions */
                            params?: {
                                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                                name?: string;
                                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                                schema?: any;
                            }[];
                        } | null;
                        /** @description When creating a listener from an existing FFI, this is the pathname of the event on that FFI to be detected by this listener */
                        eventPath?: string;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the event, used in combination with eventPath */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                        location?: any;
                    }[];
                    /** @description Deprecated: Please use 'interface' in the array of 'filters' instead */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description Deprecated: Please use 'location' in the array of 'filters' instead */
                    location?: any;
                    /** @description A descriptive name for the listener */
                    name?: string;
                    /** @description Options that control how the listener subscribes to events from the underlying blockchain */
                    options?: {
                        /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
                        firstEvent?: string;
                    } | null;
                    /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
                    topic?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A concatenation of all the stringified signature of the event and location, as computed by the blockchain plugin */
                        signature?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postContractQueryNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
                    errors?: {
                        /** @description A description of the smart contract error */
                        description?: string;
                        /** @description The name of the error */
                        name?: string;
                        /** @description An array of error parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    }[];
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
                    input?: any;
                    /**
                     * Format: uuid
                     * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
                     */
                    interface?: string | null;
                    /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                    location?: any;
                    /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
                    method?: {
                        /** @description A description of the smart contract method */
                        description?: string;
                        /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
                        details?: any;
                        /** @description The name of the method */
                        name?: string;
                        /** @description An array of method parameter/argument definitions */
                        params?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                        /** @description An array of method return definitions */
                        returns?: {
                            /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                            name?: string;
                            /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                            schema?: any;
                        }[];
                    } | null;
                    /** @description The pathname of the method on the specified FFI */
                    methodPath?: string;
                    /** @description A map of named inputs that will be passed through to the blockchain connector */
                    options?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": any;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.hash"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.name"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.path"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.public"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "blob.size"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "datatype.name"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "datatype.version"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                public?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                validator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                value?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postDataNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The optional datatype to use for validation of the in-line data */
                    datatype?: {
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                        version?: string;
                    } | null;
                    /**
                     * Format: uuid
                     * @description The UUID of the referenced data resource
                     */
                    id?: string | null;
                    /** @description The data validator type to use for in-line data */
                    validator?: string;
                    /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                    value?: any;
                };
                "multipart/form-data": {
                    /** @description Success */
                    autometa?: string;
                    /** @description Success */
                    "datatype.name"?: string;
                    /** @description Success */
                    "datatype.version"?: string;
                    /** Format: binary */
                    "filename.ext"?: string;
                    /** @description Success */
                    metadata?: string;
                    /** @description Success */
                    validator?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string | null;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataByIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteDataNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataBlobNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postDataBlobPublishNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blob ID */
                dataid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string | null;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataMsgsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The data item ID */
                dataid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataValueNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blob ID */
                dataid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postDataValuePublishNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The blob ID */
                dataid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string | null;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataSubPathsNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The parent path to query */
                parent: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatatypesNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                validator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                version?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewDatatypeNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The name of the datatype */
                    name?: string;
                    /**
                     * @description The validator that should be used to verify this datatype
                     * @enum {string}
                     */
                    validator?: "json" | "none" | "definition";
                    /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                    value?: any;
                    /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                    version?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatatypeByNameNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name of the datatype */
                name: string;
                /** @description The version of the datatype */
                version: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the datatype was created
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the datatype
                         */
                        id?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message that was used to publish this datatype to the network
                         */
                        message?: string | null;
                        /** @description The name of the datatype */
                        name?: string;
                        /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
                        namespace?: string;
                        /**
                         * @description The validator that should be used to verify this datatype
                         * @enum {string}
                         */
                        validator?: "json" | "none" | "definition";
                        /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
                        value?: any;
                        /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
                        version?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getEventsNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the record that this item references in its 'reference' field */
                fetchreferences?: string;
                /** @description When set, the API will return the record that this item references in its 'reference' field */
                fetchreference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                correlator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                reference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getEventByIDNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the record that this item references in its 'reference' field */
                fetchreference?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The event ID */
                eid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getGroupsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                ledger?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time when the group was first used to send a message in the network
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The identifier hash of this group. Derived from the name and group members
                         */
                        hash?: string | null;
                        /** @description The local namespace of the group */
                        localNamespace?: string;
                        /** @description The list of members in this privacy group */
                        members?: {
                            /** @description The DID of the group member */
                            identity?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the node that receives a copy of the off-chain message for the identity
                             */
                            node?: string | null;
                        }[];
                        /**
                         * Format: uuid
                         * @description The message used to broadcast this group privately to the members
                         */
                        message?: string | null;
                        /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
                        name?: string;
                        /** @description The namespace of the group within the multiparty network */
                        namespace?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getGroupByHashNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The hash of the group */
                hash: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time when the group was first used to send a message in the network
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description The identifier hash of this group. Derived from the name and group members
                         */
                        hash?: string | null;
                        /** @description The local namespace of the group */
                        localNamespace?: string;
                        /** @description The list of members in this privacy group */
                        members?: {
                            /** @description The DID of the group member */
                            identity?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the node that receives a copy of the off-chain message for the identity
                             */
                            node?: string | null;
                        }[];
                        /**
                         * Format: uuid
                         * @description The message used to broadcast this group privately to the members
                         */
                        message?: string | null;
                        /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
                        name?: string;
                        /** @description The namespace of the group within the multiparty network */
                        namespace?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentitiesNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                        /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
                        verifiers?: {
                            /**
                             * @description The type of the verifier
                             * @enum {string}
                             */
                            type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                            value?: string;
                        }[];
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewIdentityNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the identity. Part of the updatable profile information of an identity */
                    description?: string;
                    /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
                    key?: string;
                    /** @description The name of the identity. The name must be unique within the type and namespace */
                    name?: string;
                    /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
                    parent?: string;
                    /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                    profile?: any;
                    /** @description The type of the identity */
                    type?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentityByIDNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    patchUpdateIdentityNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the identity. Part of the updatable profile information of an identity */
                    description?: string;
                    /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                    profile?: any;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentityDIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description See https://www.w3.org/TR/did-core/#json-ld */
                        "@context"?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        authentication?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        id?: string;
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        verificationMethod?: {
                            /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
                            blockchainAcountId?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            controller?: string;
                            /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
                            dataExchangePeerID?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            id?: string;
                            /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
                            mspIdentityString?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            type?: string;
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getIdentityVerifiersNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                identity?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                value?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity ID, which is a UUID generated by FireFly */
                iid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time this verifier was created on this node
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity that has claimed this verifier
                         */
                        identity?: string | null;
                        /** @description The namespace of the verifier */
                        namespace?: string;
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgsNamespace: {
        parameters: {
            query?: {
                /** @description Fetch the data and include it in the messages returned */
                fetchdata?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                author?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                cid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                confirmed?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                datahash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                group?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pins?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                rejectreason?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                state?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tag?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topics?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "txparent.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                txtype?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgByIDNamespace: {
        parameters: {
            query?: {
                /** @description Fetch the data and include it in the messages returned */
                fetchdata?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description An optional in-line hash reference to a previously uploaded binary data blob */
                            blob?: {
                                /**
                                 * Format: byte
                                 * @description The hash of the binary blob data
                                 */
                                hash?: string | null;
                                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                                name?: string;
                                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                                path?: string;
                                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                                public?: string;
                                /**
                                 * Format: int64
                                 * @description The size of the binary data
                                 */
                                size?: number;
                            } | null;
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgDataNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An optional hash reference to a binary blob attachment */
                        blob?: {
                            /**
                             * Format: byte
                             * @description The hash of the binary blob data
                             */
                            hash?: string | null;
                            /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                            name?: string;
                            /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                            path?: string;
                            /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                            public?: string;
                            /**
                             * Format: int64
                             * @description The size of the binary data
                             */
                            size?: number;
                        } | null;
                        /**
                         * Format: date-time
                         * @description The creation time of the data resource
                         */
                        created?: string | null;
                        /** @description The optional datatype to use of validation of this data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the data resource
                         */
                        id?: string;
                        /** @description The namespace of the data resource */
                        namespace?: string;
                        /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                        public?: string;
                        /** @description The data validator type */
                        validator?: string;
                        /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
                        value?: any;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgEventsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                correlator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                reference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getMsgTxnNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The message ID */
                msgid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
                        blockchainIds?: string[];
                        /**
                         * Format: date-time
                         * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction
                         */
                        id?: string;
                        /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
                        idempotencyKey?: string;
                        /** @description The namespace of the FireFly transaction */
                        namespace?: string;
                        /**
                         * @description The type of the FireFly transaction
                         * @enum {string}
                         */
                        type?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewMessageBroadcastNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                    data?: {
                        /** @description The optional datatype to use for validation of the in-line data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the referenced data resource
                         */
                        id?: string | null;
                        /** @description The data validator type to use for in-line data */
                        validator?: string;
                        /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                        value?: any;
                    }[];
                    /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                    group?: {
                        /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                        members?: {
                            /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                            identity?: string;
                            /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                            node?: string;
                        }[];
                        /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                        name?: string;
                    } | null;
                    /** @description The message header contains all fields that are used to build the message hash */
                    header?: {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: uuid
                         * @description The correlation ID of the message. Set this when a message is a response to another message
                         */
                        cid?: string | null;
                        /**
                         * Format: byte
                         * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                         */
                        group?: string | null;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The message tag indicates the purpose of the message to the applications that process it */
                        tag?: string;
                        /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                        topics?: string[];
                        /**
                         * @description The type of transaction used to order/deliver this message
                         * @enum {string}
                         */
                        txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                        /**
                         * @description The type of the message
                         * @enum {string}
                         */
                        type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                    };
                    /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewMessagePrivateNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                    data?: {
                        /** @description The optional datatype to use for validation of the in-line data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the referenced data resource
                         */
                        id?: string | null;
                        /** @description The data validator type to use for in-line data */
                        validator?: string;
                        /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                        value?: any;
                    }[];
                    /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                    group?: {
                        /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                        members?: {
                            /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                            identity?: string;
                            /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                            node?: string;
                        }[];
                        /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                        name?: string;
                    } | null;
                    /** @description The message header contains all fields that are used to build the message hash */
                    header?: {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: uuid
                         * @description The correlation ID of the message. Set this when a message is a response to another message
                         */
                        cid?: string | null;
                        /**
                         * Format: byte
                         * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                         */
                        group?: string | null;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The message tag indicates the purpose of the message to the applications that process it */
                        tag?: string;
                        /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                        topics?: string[];
                        /**
                         * @description The type of transaction used to order/deliver this message
                         * @enum {string}
                         */
                        txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                        /**
                         * @description The type of the message
                         * @enum {string}
                         */
                        type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                    };
                    /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description The list of data elements attached to the message */
                        data?: {
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                        }[];
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewMessageRequestReplyNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                    data?: {
                        /** @description The optional datatype to use for validation of the in-line data */
                        datatype?: {
                            /** @description The name of the datatype */
                            name?: string;
                            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                            version?: string;
                        } | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the referenced data resource
                         */
                        id?: string | null;
                        /** @description The data validator type to use for in-line data */
                        validator?: string;
                        /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                        value?: any;
                    }[];
                    /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                    group?: {
                        /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                        members?: {
                            /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                            identity?: string;
                            /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                            node?: string;
                        }[];
                        /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                        name?: string;
                    } | null;
                    /** @description The message header contains all fields that are used to build the message hash */
                    header?: {
                        /** @description The DID of identity of the submitter */
                        author?: string;
                        /**
                         * Format: uuid
                         * @description The correlation ID of the message. Set this when a message is a response to another message
                         */
                        cid?: string | null;
                        /**
                         * Format: byte
                         * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                         */
                        group?: string | null;
                        /** @description The on-chain signing key used to sign the transaction */
                        key?: string;
                        /** @description The message tag indicates the purpose of the message to the applications that process it */
                        tag?: string;
                        /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                        topics?: string[];
                        /**
                         * @description The type of transaction used to order/deliver this message
                         * @enum {string}
                         */
                        txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                        /**
                         * @description The type of the message
                         * @enum {string}
                         */
                        type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                    };
                    /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                    idempotencyKey?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch in which the message was pinned/transferred
                         */
                        batch?: string | null;
                        /**
                         * Format: date-time
                         * @description The timestamp of when the message was confirmed/rejected
                         */
                        confirmed?: string | null;
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description An optional in-line hash reference to a previously uploaded binary data blob */
                            blob?: {
                                /**
                                 * Format: byte
                                 * @description The hash of the binary blob data
                                 */
                                hash?: string | null;
                                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                                name?: string;
                                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                                path?: string;
                                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                                public?: string;
                                /**
                                 * Format: int64
                                 * @description The size of the binary data
                                 */
                                size?: number;
                            } | null;
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: byte
                             * @description The hash of the referenced data
                             */
                            hash?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /**
                         * Format: byte
                         * @description The hash of the message. Derived from the header, which includes the data hash
                         */
                        hash?: string | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: date-time
                             * @description The creation time of the message
                             */
                            created?: string | null;
                            /**
                             * Format: byte
                             * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
                             */
                            datahash?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the message. Unique to each message
                             */
                            id?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The namespace of the message within the multiparty network */
                            namespace?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /** @description The parent transaction that originally triggered this message */
                            txparent?: {
                                /**
                                 * Format: uuid
                                 * @description The UUID of the FireFly transaction
                                 */
                                id?: string | null;
                                /** @description The type of the FireFly transaction */
                                type?: string;
                            } | null;
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                        /** @description The local namespace of the message */
                        localNamespace?: string;
                        /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
                        pins?: string[];
                        /** @description If a message was rejected, provides details on the rejection reason */
                        rejectReason?: string;
                        /**
                         * @description The current state of the message
                         * @enum {string}
                         */
                        state?: "staged" | "ready" | "sent" | "pending" | "confirmed" | "rejected" | "cancelled";
                        /**
                         * Format: uuid
                         * @description The ID of the transaction used to order/deliver this message
                         */
                        txid?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNetworkActionNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * @description The action to be performed
                     * @enum {string}
                     */
                    type?: "terminate";
                };
            };
        };
        responses: {
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description The action to be performed
                         * @enum {string}
                         */
                        type?: "terminate";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkDIDDocByDIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity DID */
                did: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description See https://www.w3.org/TR/did-core/#json-ld */
                        "@context"?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        authentication?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        id?: string;
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        verificationMethod?: {
                            /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
                            blockchainAcountId?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            controller?: string;
                            /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
                            dataExchangePeerID?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            id?: string;
                            /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
                            mspIdentityString?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            type?: string;
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkIdentitiesNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                        /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
                        verifiers?: {
                            /**
                             * @description The type of the verifier
                             * @enum {string}
                             */
                            type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                            value?: string;
                        }[];
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkIdentityByDIDNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity DID */
                did: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                        /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
                        verifiers?: {
                            /**
                             * @description The type of the verifier
                             * @enum {string}
                             */
                            type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                            value?: string;
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkNodesNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkNodeNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name or ID of the node */
                nameOrId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNodesSelfNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": any;
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkOrgsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewOrganizationNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the identity. Part of the updatable profile information of an identity */
                    description?: string;
                    /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
                    key?: string;
                    /** @description The name of the identity. The name must be unique within the type and namespace */
                    name?: string;
                    /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
                    parent?: string;
                    /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                    profile?: any;
                    /** @description The type of the identity */
                    type?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkOrgNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name or ID of the org */
                nameOrId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewOrganizationSelfNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": any;
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNextPinsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                context?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                identity?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                nonce?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: byte
                         * @description The context the next-pin applies to - the hash of the privacy group-hash + topic. The group-hash is only known to the participants (can itself contain a salt in the group-name). This context is combined with the member and nonce to determine the final hash that is written on-chain
                         */
                        context?: string | null;
                        /**
                         * Format: byte
                         * @description The unique masked pin string
                         */
                        hash?: string | null;
                        /** @description The member of the privacy group the next-pin applies to */
                        identity?: string;
                        /** @description The namespace of the next-pin */
                        namespace?: string;
                        /**
                         * Format: int64
                         * @description The numeric index - which is monotonically increasing for each member of the privacy group
                         */
                        nonce?: number;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOpsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                error?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                input?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                output?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                plugin?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                retry?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                status?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOpByIDNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return additional status information if available */
                fetchstatus?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The operation ID key to get */
                opid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Additional detailed information about an operation provided by the connector */
                        detail?: unknown;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postOpRetryNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The UUID of the operation */
                opid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": any;
            };
        };
        responses: {
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPinsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                dispatched?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                index?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                masked?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch of messages this pin is part of
                         */
                        batch?: string | null;
                        /**
                         * Format: byte
                         * @description The manifest hash batch of messages this pin is part of
                         */
                        batchHash?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the FireFly node created the pin
                         */
                        created?: string | null;
                        /** @description Once true, this pin has been processed and will not be processed again */
                        dispatched?: boolean;
                        /**
                         * Format: byte
                         * @description The hash represents a topic within a message in the batch. If a message has multiple topics, then multiple pins are created. If the message is private, the hash is masked for privacy
                         */
                        hash?: string | null;
                        /**
                         * Format: int64
                         * @description The index of this pin within the batch. One pin is created for each topic, of each message in the batch
                         */
                        index?: number;
                        /** @description True if the pin is for a private message, and hence is masked with the group ID and salted with a nonce so observers of the blockchain cannot use pin hash to match this transaction to other transactions or participants */
                        masked?: boolean;
                        /** @description The namespace of the pin */
                        namespace?: string;
                        /**
                         * Format: int64
                         * @description The order of the pin in the local FireFly database, which matches the order in which pins were delivered to FireFly by the blockchain connector event stream
                         */
                        sequence?: number;
                        /** @description The blockchain signing key that submitted this transaction, as passed through to FireFly by the smart contract that emitted the blockchain event */
                        signer?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postPinsRewindNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * Format: uuid
                     * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
                     */
                    batch?: string | null;
                    /**
                     * Format: int64
                     * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
                     */
                    sequence?: number;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
                         */
                        batch?: string | null;
                        /**
                         * Format: int64
                         * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
                         */
                        sequence?: number;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getStatusNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Information about the multi-party system configured on this namespace */
                        multiparty?: {
                            /** @description Information about the multi-party smart contract configured for this namespace */
                            contract?: {
                                /** @description The currently active FireFly smart contract */
                                active?: {
                                    /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                    firstEvent?: string;
                                    /** @description The index of this contract in the config file */
                                    index?: number;
                                    /** @description Additional info about the current status of the multi-party contract */
                                    info?: {
                                        /** @description The identifier for the final blockchain event received from this contract before termination */
                                        finalEvent?: string;
                                        /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                        subscription?: string;
                                        /** @description The version of this multiparty contract */
                                        version?: number;
                                    };
                                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                    location?: any;
                                } | null;
                                /** @description Previously-terminated FireFly smart contracts */
                                terminated?: {
                                    /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                    firstEvent?: string;
                                    /** @description The index of this contract in the config file */
                                    index?: number;
                                    /** @description Additional info about the current status of the multi-party contract */
                                    info?: {
                                        /** @description The identifier for the final blockchain event received from this contract before termination */
                                        finalEvent?: string;
                                        /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                        subscription?: string;
                                        /** @description The version of this multiparty contract */
                                        version?: number;
                                    };
                                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                    location?: any;
                                }[];
                            } | null;
                            /** @description Whether multi-party mode is enabled for this namespace */
                            enabled?: boolean;
                        };
                        /** @description The namespace that this status applies to */
                        namespace?: {
                            /**
                             * Format: date-time
                             * @description The time the namespace was created
                             */
                            created?: string | null;
                            /** @description A description of the namespace */
                            description?: string;
                            /** @description The local namespace name */
                            name?: string;
                            /** @description The shared namespace name within the multiparty network */
                            networkName?: string;
                        } | null;
                        /** @description Details of the local node */
                        node?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the node, if registered
                             */
                            id?: string;
                            /** @description The name of this node, as specified in the local configuration */
                            name?: string;
                            /** @description Whether the node has been successfully registered */
                            registered?: boolean;
                        } | null;
                        /** @description Details of the root organization identity registered for this namespace on the local node */
                        org?: {
                            /** @description The DID of the organization identity, if registered */
                            did?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the organization, if registered
                             */
                            id?: string;
                            /** @description The name of the node operator organization, as specified in the local configuration */
                            name?: string;
                            /** @description Whether the organization has been successfully registered */
                            registered?: boolean;
                            /** @description Array of verifiers (blockchain keys) owned by this identity */
                            verifiers?: {
                                /**
                                 * @description The type of the verifier
                                 * @enum {string}
                                 */
                                type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                                /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                                value?: string;
                            }[];
                        } | null;
                        /** @description Information about plugins configured on this namespace */
                        plugins?: {
                            /** @description The blockchain plugins on this namespace */
                            blockchain?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The data exchange plugins on this namespace */
                            dataExchange?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The database plugins on this namespace */
                            database?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The event plugins on this namespace */
                            events?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The identity plugins on this namespace */
                            identity?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The shared storage plugins on this namespace */
                            sharedStorage?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The token plugins on this namespace */
                            tokens?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getStatusBatchManagerNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An array of currently active batch processors */
                        processors?: {
                            /** @description The type of dispatcher for this processor */
                            dispatcher?: string;
                            /** @description The name of the processor, which includes details of the attributes of message are allocated to this processor */
                            name?: string;
                            /** @description The flush status for this batch processor */
                            status?: {
                                /**
                                 * Format: int64
                                 * @description The average byte size of each batch
                                 */
                                averageBatchBytes?: number;
                                /**
                                 * Format: double
                                 * @description The average number of data attachments included in each batch
                                 */
                                averageBatchData?: number;
                                /**
                                 * Format: double
                                 * @description The average number of messages included in each batch
                                 */
                                averageBatchMessages?: number;
                                /**
                                 * Format: int64
                                 * @description The average amount of time spent flushing each batch
                                 */
                                averageFlushTimeMS?: number;
                                /** @description True if the batch flush is in a retry loop, due to errors being returned by the plugins */
                                blocked?: boolean;
                                /** @description True if the current batch flush has been cancelled */
                                cancelled?: boolean;
                                /**
                                 * Format: uuid
                                 * @description If a flush is in progress, this is the UUID of the batch being flushed
                                 */
                                flushing?: string | null;
                                /** @description The last error received by this batch processor while flushing */
                                lastFlushError?: string;
                                /**
                                 * Format: date-time
                                 * @description The time of the last flush
                                 */
                                lastFlushErrorTime?: string | null;
                                /**
                                 * Format: date-time
                                 * @description The last time a flush was performed
                                 */
                                lastFlushStartTime?: string | null;
                                /**
                                 * Format: int64
                                 * @description The total count of batches flushed by this processor since it started
                                 */
                                totalBatches?: number;
                                /**
                                 * Format: int64
                                 * @description The total count of error flushed encountered by this processor since it started
                                 */
                                totalErrors?: number;
                            };
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getStatusMultipartyNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Information about the active and terminated multi-party smart contracts configured for this namespace */
                        contracts?: {
                            /** @description The currently active FireFly smart contract */
                            active?: {
                                /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                firstEvent?: string;
                                /** @description The index of this contract in the config file */
                                index?: number;
                                /** @description Additional info about the current status of the multi-party contract */
                                info?: {
                                    /** @description The identifier for the final blockchain event received from this contract before termination */
                                    finalEvent?: string;
                                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                    subscription?: string;
                                    /** @description The version of this multiparty contract */
                                    version?: number;
                                };
                                /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                location?: any;
                                /** @description The status of the contract listener. One of 'syncing', 'synced', or 'unknown' */
                                status?: string;
                            } | null;
                            /** @description Previously-terminated FireFly smart contracts */
                            terminated?: {
                                /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                firstEvent?: string;
                                /** @description The index of this contract in the config file */
                                index?: number;
                                /** @description Additional info about the current status of the multi-party contract */
                                info?: {
                                    /** @description The identifier for the final blockchain event received from this contract before termination */
                                    finalEvent?: string;
                                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                    subscription?: string;
                                    /** @description The version of this multiparty contract */
                                    version?: number;
                                };
                                /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                location?: any;
                            }[];
                        } | null;
                        /** @description Whether multi-party mode is enabled for this namespace */
                        enabled?: boolean;
                        /** @description Details of the local node */
                        node?: {
                            /**
                             * Format: uuid
                             * @description The ID of the pending message that broadcast the identity claim to the network
                             */
                            pendingRegistrationMessageId?: string | null;
                            /** @description The status of the node registration, one of 'unregistered', 'registering', 'registered', and 'unknown' */
                            status?: string;
                        };
                        /** @description Details of the root organization identity registered for this namespace on the local node */
                        org?: {
                            /**
                             * Format: uuid
                             * @description The ID of the pending message that broadcast the identity claim to the network
                             */
                            pendingRegistrationMessageId?: string | null;
                            /** @description The status of the organization registration, one of 'unregistered', 'registering', 'registered', and 'unknown' */
                            status?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSubscriptionsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                events?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                filters?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                options?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                transport?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putSubscriptionNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Server-side filter to apply to events */
                    filter?: {
                        /** @description Deprecated: Please use 'message.author' instead */
                        author?: string;
                        /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                        blockchainevent?: {
                            /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                            listener?: string;
                            /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                            name?: string;
                        };
                        /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                        events?: string;
                        /** @description Deprecated: Please use 'message.group' instead */
                        group?: string;
                        /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                        message?: {
                            /** @description Regular expression to apply to the message 'header.author' field */
                            author?: string;
                            /** @description Regular expression to apply to the message 'header.group' field */
                            group?: string;
                            /** @description Regular expression to apply to the message 'header.tag' field */
                            tag?: string;
                        };
                        /** @description Deprecated: Please use 'message.tag' instead */
                        tag?: string;
                        /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                        topic?: string;
                        /** @description Deprecated: Please use 'topic' instead */
                        topics?: string;
                        /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                        transaction?: {
                            /** @description Regular expression to apply to the transaction 'type' field */
                            type?: string;
                        };
                    };
                    /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                    name?: string;
                    /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                    namespace?: string;
                    /** @description Subscription options */
                    options?: {
                        /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                        batch?: boolean | null;
                        /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                        batchTimeout?: string | null;
                        /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                        fastack?: boolean;
                        /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                        firstEvent?: string | null;
                        /** @description Webhooks only: Static headers to set on the webhook request */
                        headers?: any;
                        /** @description Webhooks only: a set of options for HTTP */
                        httpOptions?: {
                            /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                            connectionTimeout?: string;
                            /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                            expectContinueTimeout?: string;
                            /** @description The max duration to hold a HTTP keepalive connection between calls */
                            idleTimeout?: string;
                            /** @description The max number of idle connections to hold pooled */
                            maxIdleConns?: number;
                            /** @description HTTP proxy URL to use for outbound requests to the webhook */
                            proxyURL?: string | null;
                            /** @description The max duration to hold a TLS handshake alive */
                            requestTimeout?: string;
                            /** @description The max duration to hold a TLS handshake alive */
                            tlsHandshakeTimeout?: string;
                        };
                        /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                        input?: {
                            /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                            body?: string;
                            /** @description A top-level property of the first data input, to use for headers */
                            headers?: string;
                            /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                            path?: string;
                            /** @description A top-level property of the first data input, to use for query parameters */
                            query?: string;
                            /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                            replytx?: string;
                        };
                        /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                        json?: boolean;
                        /** @description Webhooks only: HTTP method to invoke. Default=POST */
                        method?: string;
                        /** @description Webhooks only: Static query params to set on the webhook request */
                        query?: any;
                        /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                        readAhead?: number | null;
                        /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                        reply?: boolean;
                        /** @description Webhooks only: The tag to set on the reply message */
                        replytag?: string;
                        /** @description Webhooks only: The transaction type to set on the reply message */
                        replytx?: string;
                        /** @description Webhooks only: a set of options for retrying the webhook call */
                        retry?: {
                            /** @description Number of times to retry the webhook call in case of failure */
                            count?: number;
                            /** @description Enables retry on HTTP calls, defaults to false */
                            enabled?: boolean;
                            /** @description Initial delay between retries when we retry the webhook call */
                            initialDelay?: string;
                            /** @description Max delay between retries when we retry the webhookcall */
                            maxDelay?: string;
                        };
                        /** @description The name of an existing TLS configuration associated to the namespace to use */
                        tlsConfigName?: string;
                        /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                        url?: string;
                        /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                        withData?: boolean | null;
                    };
                    /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                    transport?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string | null;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewSubscriptionNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Server-side filter to apply to events */
                    filter?: {
                        /** @description Deprecated: Please use 'message.author' instead */
                        author?: string;
                        /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                        blockchainevent?: {
                            /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                            listener?: string;
                            /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                            name?: string;
                        };
                        /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                        events?: string;
                        /** @description Deprecated: Please use 'message.group' instead */
                        group?: string;
                        /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                        message?: {
                            /** @description Regular expression to apply to the message 'header.author' field */
                            author?: string;
                            /** @description Regular expression to apply to the message 'header.group' field */
                            group?: string;
                            /** @description Regular expression to apply to the message 'header.tag' field */
                            tag?: string;
                        };
                        /** @description Deprecated: Please use 'message.tag' instead */
                        tag?: string;
                        /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                        topic?: string;
                        /** @description Deprecated: Please use 'topic' instead */
                        topics?: string;
                        /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                        transaction?: {
                            /** @description Regular expression to apply to the transaction 'type' field */
                            type?: string;
                        };
                    };
                    /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                    name?: string;
                    /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                    namespace?: string;
                    /** @description Subscription options */
                    options?: {
                        /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                        batch?: boolean | null;
                        /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                        batchTimeout?: string | null;
                        /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                        fastack?: boolean;
                        /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                        firstEvent?: string | null;
                        /** @description Webhooks only: Static headers to set on the webhook request */
                        headers?: any;
                        /** @description Webhooks only: a set of options for HTTP */
                        httpOptions?: {
                            /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                            connectionTimeout?: string;
                            /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                            expectContinueTimeout?: string;
                            /** @description The max duration to hold a HTTP keepalive connection between calls */
                            idleTimeout?: string;
                            /** @description The max number of idle connections to hold pooled */
                            maxIdleConns?: number;
                            /** @description HTTP proxy URL to use for outbound requests to the webhook */
                            proxyURL?: string | null;
                            /** @description The max duration to hold a TLS handshake alive */
                            requestTimeout?: string;
                            /** @description The max duration to hold a TLS handshake alive */
                            tlsHandshakeTimeout?: string;
                        };
                        /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                        input?: {
                            /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                            body?: string;
                            /** @description A top-level property of the first data input, to use for headers */
                            headers?: string;
                            /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                            path?: string;
                            /** @description A top-level property of the first data input, to use for query parameters */
                            query?: string;
                            /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                            replytx?: string;
                        };
                        /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                        json?: boolean;
                        /** @description Webhooks only: HTTP method to invoke. Default=POST */
                        method?: string;
                        /** @description Webhooks only: Static query params to set on the webhook request */
                        query?: any;
                        /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                        readAhead?: number | null;
                        /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                        reply?: boolean;
                        /** @description Webhooks only: The tag to set on the reply message */
                        replytag?: string;
                        /** @description Webhooks only: The transaction type to set on the reply message */
                        replytx?: string;
                        /** @description Webhooks only: a set of options for retrying the webhook call */
                        retry?: {
                            /** @description Number of times to retry the webhook call in case of failure */
                            count?: number;
                            /** @description Enables retry on HTTP calls, defaults to false */
                            enabled?: boolean;
                            /** @description Initial delay between retries when we retry the webhook call */
                            initialDelay?: string;
                            /** @description Max delay between retries when we retry the webhookcall */
                            maxDelay?: string;
                        };
                        /** @description The name of an existing TLS configuration associated to the namespace to use */
                        tlsConfigName?: string;
                        /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                        url?: string;
                        /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                        withData?: boolean | null;
                    };
                    /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                    transport?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string | null;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSubscriptionByIDNamespace: {
        parameters: {
            query?: {
                /** @description When set, the API will return additional status information if available */
                fetchstatus?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The subscription ID */
                subid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteSubscriptionNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The subscription ID */
                subid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSubscriptionEventsFilteredNamespace: {
        parameters: {
            query?: {
                /** @description The sequence ID in the raw event stream to start indexing through events from. Leave blank to start indexing from the most recent events */
                startsequence?: string;
                /** @description The sequence ID in the raw event stream to stop indexing through events at. Leave blank to start indexing from the most recent events */
                endsequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                correlator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                reference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The subscription ID */
                subid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenAccountsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain signing identity this balance applies to */
                        key?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenAccountPoolsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The key for the token account. The exact format may vary based on the token connector use */
                key: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this balance entry applies to
                         */
                        pool?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenApprovalsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                active?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                approved?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainevent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                localid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                messagehash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                operator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                protocolid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                subject?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
                        active?: boolean;
                        /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                        approved?: boolean;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the token approval
                         */
                        created?: string | null;
                        /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token approval, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the approval, which must match the namespace of the token pool */
                        namespace?: string;
                        /** @description The blockchain identity that is granted the approval */
                        operator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this approval applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
                        subject?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenApprovalNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                    approved?: boolean;
                    /** @description Input only field, with token connector specific configuration of the approval.  See your chosen token connector documentation for details */
                    config?: any;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the approval, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the approval */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The blockchain identity that is granted the approval */
                    operator?: string;
                    /**
                     * Format: uuid
                     * @description The UUID the token pool this approval applies to
                     */
                    pool?: string | null;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
                        active?: boolean;
                        /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                        approved?: boolean;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the token approval
                         */
                        created?: string | null;
                        /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token approval, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the approval, which must match the namespace of the token pool */
                        namespace?: string;
                        /** @description The blockchain identity that is granted the approval */
                        operator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this approval applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
                        subject?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
                        active?: boolean;
                        /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                        approved?: boolean;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the token approval
                         */
                        created?: string | null;
                        /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token approval, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the approval, which must match the namespace of the token pool */
                        namespace?: string;
                        /** @description The blockchain identity that is granted the approval */
                        operator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this approval applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
                        subject?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenBalancesNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                balance?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tokenindex?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                uri?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The numeric balance. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when interpreting the balance. For example, with 18 decimals a fractional balance of 10.234 will be returned as 10,234,000,000,000,000,000 */
                        balance?: string;
                        /** @description The token connector that is responsible for the token pool of this balance entry */
                        connector?: string;
                        /** @description The blockchain signing identity this balance applies to */
                        key?: string;
                        /** @description The namespace of the token pool for this balance entry */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this balance entry applies to
                         */
                        pool?: string | null;
                        /** @description The index of the token within the pool that this balance applies to */
                        tokenIndex?: string;
                        /**
                         * Format: date-time
                         * @description The last time the balance was updated by applying a transfer event
                         */
                        updated?: string | null;
                        /** @description The URI of the token this balance entry applies to */
                        uri?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenBurnNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                    amount?: string;
                    /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description The source account for the transfer. On input defaults to the value of 'key' */
                    from?: string;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The name or UUID of a token pool */
                    pool?: string;
                    /** @description The target account for the transfer. On input defaults to the value of 'key' */
                    to?: string;
                    /** @description The index of the token within the pool that this transfer applies to */
                    tokenIndex?: string;
                    /** @description The URI of the token this transfer applies to */
                    uri?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenConnectorsNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The name of the token connector, as configured in the FireFly core configuration file */
                        name?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenMintNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                    amount?: string;
                    /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description The source account for the transfer. On input defaults to the value of 'key' */
                    from?: string;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The name or UUID of a token pool */
                    pool?: string;
                    /** @description The target account for the transfer. On input defaults to the value of 'key' */
                    to?: string;
                    /** @description The index of the token within the pool that this transfer applies to */
                    tokenIndex?: string;
                    /** @description The URI of the token this transfer applies to */
                    uri?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenPoolsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                active?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                decimals?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interfaceformat?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                locator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                networkname?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                published?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                standard?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                symbol?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenPoolNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
                /** @description When true the definition will be published to all other members of the multiparty network */
                publish?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Input only field, with token connector specific configuration of the pool, such as an existing Ethereum address and block number to used to index the pool. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                    connector?: string;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                    key?: string;
                    /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                    name?: string;
                    /** @description The published name of the token pool within the multiparty network */
                    networkName?: string;
                    /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                    symbol?: string;
                    /**
                     * @description The type of token the pool contains, such as fungible/non-fungible
                     * @enum {string}
                     */
                    type?: "fungible" | "nonfungible";
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenPoolByNameOrIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token pool name or ID */
                nameOrId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteTokenPoolNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token pool name or ID */
                nameOrId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenPoolPublishNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token pool name or ID */
                nameOrId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenTransfersNamespace: {
        parameters: {
            query?: {
                /** @description The sending or receiving token account for a token transfer */
                fromOrTo?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                amount?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainevent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                from?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                localid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                messagehash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                protocolid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                to?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tokenindex?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                uri?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenTransferNamespace: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                    amount?: string;
                    /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description The source account for the transfer. On input defaults to the value of 'key' */
                    from?: string;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The name or UUID of a token pool */
                    pool?: string;
                    /** @description The target account for the transfer. On input defaults to the value of 'key' */
                    to?: string;
                    /** @description The index of the token within the pool that this transfer applies to */
                    tokenIndex?: string;
                    /** @description The URI of the token this transfer applies to */
                    uri?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenTransferByIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token transfer ID */
                transferId: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnsNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainids?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
                        blockchainIds?: string[];
                        /**
                         * Format: date-time
                         * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction
                         */
                        id?: string;
                        /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
                        idempotencyKey?: string;
                        /** @description The namespace of the FireFly transaction */
                        namespace?: string;
                        /**
                         * @description The type of the FireFly transaction
                         * @enum {string}
                         */
                        type?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnByIDNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainids?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
                        blockchainIds?: string[];
                        /**
                         * Format: date-time
                         * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction
                         */
                        id?: string;
                        /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
                        idempotencyKey?: string;
                        /** @description The namespace of the FireFly transaction */
                        namespace?: string;
                        /**
                         * @description The type of the FireFly transaction
                         * @enum {string}
                         */
                        type?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnBlockchainEventsNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID assigned to the event by FireFly
                         */
                        id?: string;
                        /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
                        info?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
                         */
                        listener?: string | null;
                        /** @description The name of the event in the blockchain smart contract */
                        name?: string;
                        /** @description The namespace of the listener that detected this blockchain event */
                        namespace?: string;
                        /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
                        output?: any;
                        /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
                        protocolId?: string;
                        /** @description The blockchain plugin or token service that detected the event */
                        source?: string;
                        /**
                         * Format: date-time
                         * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
                         */
                        timestamp?: string | null;
                        /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
                        tx?: {
                            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
                            blockchainId?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnOpsNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnStatusNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A set of records describing the activities within the transaction known by the local FireFly node */
                        details?: {
                            /** @description If an error occurred related to the detail entry, it is included here */
                            error?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the entry referenced by this detail. The type of this record can be inferred from the entry type
                             */
                            id?: string;
                            /** @description Output details for this entry */
                            info?: any;
                            /** @description The status of the detail record. Cases where an event is required for completion, but has not arrived yet are marked with a 'pending' record */
                            status?: string;
                            /** @description A sub-type, such as an operation type, or an event type */
                            subtype?: string;
                            /**
                             * Format: date-time
                             * @description The time relevant to when the record was updated, such as the time an event was created, or the last update time of an operation
                             */
                            timestamp?: string | null;
                            /** @description The type of the transaction status detail record */
                            type?: string;
                        }[];
                        /** @description The overall computed status of the transaction, after analyzing the details during the API call */
                        status?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVerifiersNamespace: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                identity?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                value?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time this verifier was created on this node
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity that has claimed this verifier
                         */
                        identity?: string | null;
                        /** @description The namespace of the verifier */
                        namespace?: string;
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVerifierByIDNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The hash of the verifier */
                hash: string;
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time this verifier was created on this node
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity that has claimed this verifier
                         */
                        identity?: string | null;
                        /** @description The namespace of the verifier */
                        namespace?: string;
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postVerifiersResolveNamespace: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The namespace which scopes this request */
                ns: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * @description The type of the verifier
                     * @enum {string}
                     */
                    type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                    /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                    value?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNetworkAction: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * @description The action to be performed
                     * @enum {string}
                     */
                    type?: "terminate";
                };
            };
        };
        responses: {
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description The action to be performed
                         * @enum {string}
                         */
                        type?: "terminate";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkDIDDocByDID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity DID */
                did: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description See https://www.w3.org/TR/did-core/#json-ld */
                        "@context"?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        authentication?: string[];
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        id?: string;
                        /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
                        verificationMethod?: {
                            /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
                            blockchainAcountId?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            controller?: string;
                            /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
                            dataExchangePeerID?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            id?: string;
                            /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
                            mspIdentityString?: string;
                            /** @description See https://www.w3.org/TR/did-core/#service-properties */
                            type?: string;
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkIdentities: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                        /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
                        verifiers?: {
                            /**
                             * @description The type of the verifier
                             * @enum {string}
                             */
                            type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                            value?: string;
                        }[];
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkIdentityByDID: {
        parameters: {
            query?: {
                /** @description When set, the API will return the verifier for this identity */
                fetchverifiers?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The identity DID */
                did: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                        /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
                        verifiers?: {
                            /**
                             * @description The type of the verifier
                             * @enum {string}
                             */
                            type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                            value?: string;
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkNodes: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkNode: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name or ID of the node */
                nameOrId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNodesSelf: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": any;
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkOrgs: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                description?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                did?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.claim"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.update"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "messages.verification"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                parent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                profile?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewOrganization: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description A description of the identity. Part of the updatable profile information of an identity */
                    description?: string;
                    /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
                    key?: string;
                    /** @description The name of the identity. The name must be unique within the type and namespace */
                    name?: string;
                    /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
                    parent?: string;
                    /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                    profile?: any;
                    /** @description The type of the identity */
                    type?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNetworkOrg: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The name or ID of the org */
                nameOrId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewOrganizationSelf: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": any;
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The creation time of the identity
                         */
                        created?: string | null;
                        /** @description A description of the identity. Part of the updatable profile information of an identity */
                        description?: string;
                        /** @description The DID of the identity. Unique across namespaces within a FireFly network */
                        did?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the identity
                         */
                        id?: string | null;
                        /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
                        messages?: {
                            /**
                             * Format: uuid
                             * @description The UUID of claim message
                             */
                            claim?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
                             */
                            update?: string | null;
                            /**
                             * Format: uuid
                             * @description The UUID of claim message. Unset for root organization identities
                             */
                            verification?: string | null;
                        };
                        /** @description The name of the identity. The name must be unique within the type and namespace */
                        name?: string;
                        /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity. Unset for root organization identities
                         */
                        parent?: string | null;
                        /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
                        profile?: any;
                        /**
                         * @description The type of the identity
                         * @enum {string}
                         */
                        type?: "org" | "node" | "custom";
                        /**
                         * Format: date-time
                         * @description The last update time of the identity profile
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getNextPins: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                context?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                identity?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                nonce?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: byte
                         * @description The context the next-pin applies to - the hash of the privacy group-hash + topic. The group-hash is only known to the participants (can itself contain a salt in the group-name). This context is combined with the member and nonce to determine the final hash that is written on-chain
                         */
                        context?: string | null;
                        /**
                         * Format: byte
                         * @description The unique masked pin string
                         */
                        hash?: string | null;
                        /** @description The member of the privacy group the next-pin applies to */
                        identity?: string;
                        /** @description The namespace of the next-pin */
                        namespace?: string;
                        /**
                         * Format: int64
                         * @description The numeric index - which is monotonically increasing for each member of the privacy group
                         */
                        nonce?: number;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOps: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                error?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                input?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                output?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                plugin?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                retry?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                status?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOpByID: {
        parameters: {
            query?: {
                /** @description When set, the API will return additional status information if available */
                fetchstatus?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The operation ID key to get */
                opid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Additional detailed information about an operation provided by the connector */
                        detail?: unknown;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postOpRetry: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The UUID of the operation */
                opid: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": any;
            };
        };
        responses: {
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string | null;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPins: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                batch?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                dispatched?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                index?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                masked?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID of the batch of messages this pin is part of
                         */
                        batch?: string | null;
                        /**
                         * Format: byte
                         * @description The manifest hash batch of messages this pin is part of
                         */
                        batchHash?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the FireFly node created the pin
                         */
                        created?: string | null;
                        /** @description Once true, this pin has been processed and will not be processed again */
                        dispatched?: boolean;
                        /**
                         * Format: byte
                         * @description The hash represents a topic within a message in the batch. If a message has multiple topics, then multiple pins are created. If the message is private, the hash is masked for privacy
                         */
                        hash?: string | null;
                        /**
                         * Format: int64
                         * @description The index of this pin within the batch. One pin is created for each topic, of each message in the batch
                         */
                        index?: number;
                        /** @description True if the pin is for a private message, and hence is masked with the group ID and salted with a nonce so observers of the blockchain cannot use pin hash to match this transaction to other transactions or participants */
                        masked?: boolean;
                        /** @description The namespace of the pin */
                        namespace?: string;
                        /**
                         * Format: int64
                         * @description The order of the pin in the local FireFly database, which matches the order in which pins were delivered to FireFly by the blockchain connector event stream
                         */
                        sequence?: number;
                        /** @description The blockchain signing key that submitted this transaction, as passed through to FireFly by the smart contract that emitted the blockchain event */
                        signer?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postPinsRewind: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * Format: uuid
                     * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
                     */
                    batch?: string | null;
                    /**
                     * Format: int64
                     * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
                     */
                    sequence?: number;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
                         */
                        batch?: string | null;
                        /**
                         * Format: int64
                         * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
                         */
                        sequence?: number;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getStatus: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Information about the multi-party system configured on this namespace */
                        multiparty?: {
                            /** @description Information about the multi-party smart contract configured for this namespace */
                            contract?: {
                                /** @description The currently active FireFly smart contract */
                                active?: {
                                    /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                    firstEvent?: string;
                                    /** @description The index of this contract in the config file */
                                    index?: number;
                                    /** @description Additional info about the current status of the multi-party contract */
                                    info?: {
                                        /** @description The identifier for the final blockchain event received from this contract before termination */
                                        finalEvent?: string;
                                        /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                        subscription?: string;
                                        /** @description The version of this multiparty contract */
                                        version?: number;
                                    };
                                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                    location?: any;
                                } | null;
                                /** @description Previously-terminated FireFly smart contracts */
                                terminated?: {
                                    /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                    firstEvent?: string;
                                    /** @description The index of this contract in the config file */
                                    index?: number;
                                    /** @description Additional info about the current status of the multi-party contract */
                                    info?: {
                                        /** @description The identifier for the final blockchain event received from this contract before termination */
                                        finalEvent?: string;
                                        /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                        subscription?: string;
                                        /** @description The version of this multiparty contract */
                                        version?: number;
                                    };
                                    /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                    location?: any;
                                }[];
                            } | null;
                            /** @description Whether multi-party mode is enabled for this namespace */
                            enabled?: boolean;
                        };
                        /** @description The namespace that this status applies to */
                        namespace?: {
                            /**
                             * Format: date-time
                             * @description The time the namespace was created
                             */
                            created?: string | null;
                            /** @description A description of the namespace */
                            description?: string;
                            /** @description The local namespace name */
                            name?: string;
                            /** @description The shared namespace name within the multiparty network */
                            networkName?: string;
                        } | null;
                        /** @description Details of the local node */
                        node?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the node, if registered
                             */
                            id?: string;
                            /** @description The name of this node, as specified in the local configuration */
                            name?: string;
                            /** @description Whether the node has been successfully registered */
                            registered?: boolean;
                        } | null;
                        /** @description Details of the root organization identity registered for this namespace on the local node */
                        org?: {
                            /** @description The DID of the organization identity, if registered */
                            did?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the organization, if registered
                             */
                            id?: string;
                            /** @description The name of the node operator organization, as specified in the local configuration */
                            name?: string;
                            /** @description Whether the organization has been successfully registered */
                            registered?: boolean;
                            /** @description Array of verifiers (blockchain keys) owned by this identity */
                            verifiers?: {
                                /**
                                 * @description The type of the verifier
                                 * @enum {string}
                                 */
                                type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                                /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                                value?: string;
                            }[];
                        } | null;
                        /** @description Information about plugins configured on this namespace */
                        plugins?: {
                            /** @description The blockchain plugins on this namespace */
                            blockchain?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The data exchange plugins on this namespace */
                            dataExchange?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The database plugins on this namespace */
                            database?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The event plugins on this namespace */
                            events?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The identity plugins on this namespace */
                            identity?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The shared storage plugins on this namespace */
                            sharedStorage?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                            /** @description The token plugins on this namespace */
                            tokens?: {
                                /** @description The name of the plugin */
                                name?: string;
                                /** @description The type of the plugin */
                                pluginType?: string;
                            }[];
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getStatusBatchManager: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description An array of currently active batch processors */
                        processors?: {
                            /** @description The type of dispatcher for this processor */
                            dispatcher?: string;
                            /** @description The name of the processor, which includes details of the attributes of message are allocated to this processor */
                            name?: string;
                            /** @description The flush status for this batch processor */
                            status?: {
                                /**
                                 * Format: int64
                                 * @description The average byte size of each batch
                                 */
                                averageBatchBytes?: number;
                                /**
                                 * Format: double
                                 * @description The average number of data attachments included in each batch
                                 */
                                averageBatchData?: number;
                                /**
                                 * Format: double
                                 * @description The average number of messages included in each batch
                                 */
                                averageBatchMessages?: number;
                                /**
                                 * Format: int64
                                 * @description The average amount of time spent flushing each batch
                                 */
                                averageFlushTimeMS?: number;
                                /** @description True if the batch flush is in a retry loop, due to errors being returned by the plugins */
                                blocked?: boolean;
                                /** @description True if the current batch flush has been cancelled */
                                cancelled?: boolean;
                                /**
                                 * Format: uuid
                                 * @description If a flush is in progress, this is the UUID of the batch being flushed
                                 */
                                flushing?: string | null;
                                /** @description The last error received by this batch processor while flushing */
                                lastFlushError?: string;
                                /**
                                 * Format: date-time
                                 * @description The time of the last flush
                                 */
                                lastFlushErrorTime?: string | null;
                                /**
                                 * Format: date-time
                                 * @description The last time a flush was performed
                                 */
                                lastFlushStartTime?: string | null;
                                /**
                                 * Format: int64
                                 * @description The total count of batches flushed by this processor since it started
                                 */
                                totalBatches?: number;
                                /**
                                 * Format: int64
                                 * @description The total count of error flushed encountered by this processor since it started
                                 */
                                totalErrors?: number;
                            };
                        }[];
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getStatusMultiparty: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Information about the active and terminated multi-party smart contracts configured for this namespace */
                        contracts?: {
                            /** @description The currently active FireFly smart contract */
                            active?: {
                                /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                firstEvent?: string;
                                /** @description The index of this contract in the config file */
                                index?: number;
                                /** @description Additional info about the current status of the multi-party contract */
                                info?: {
                                    /** @description The identifier for the final blockchain event received from this contract before termination */
                                    finalEvent?: string;
                                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                    subscription?: string;
                                    /** @description The version of this multiparty contract */
                                    version?: number;
                                };
                                /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                location?: any;
                                /** @description The status of the contract listener. One of 'syncing', 'synced', or 'unknown' */
                                status?: string;
                            } | null;
                            /** @description Previously-terminated FireFly smart contracts */
                            terminated?: {
                                /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                                firstEvent?: string;
                                /** @description The index of this contract in the config file */
                                index?: number;
                                /** @description Additional info about the current status of the multi-party contract */
                                info?: {
                                    /** @description The identifier for the final blockchain event received from this contract before termination */
                                    finalEvent?: string;
                                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                                    subscription?: string;
                                    /** @description The version of this multiparty contract */
                                    version?: number;
                                };
                                /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                                location?: any;
                            }[];
                        } | null;
                        /** @description Whether multi-party mode is enabled for this namespace */
                        enabled?: boolean;
                        /** @description Details of the local node */
                        node?: {
                            /**
                             * Format: uuid
                             * @description The ID of the pending message that broadcast the identity claim to the network
                             */
                            pendingRegistrationMessageId?: string | null;
                            /** @description The status of the node registration, one of 'unregistered', 'registering', 'registered', and 'unknown' */
                            status?: string;
                        };
                        /** @description Details of the root organization identity registered for this namespace on the local node */
                        org?: {
                            /**
                             * Format: uuid
                             * @description The ID of the pending message that broadcast the identity claim to the network
                             */
                            pendingRegistrationMessageId?: string | null;
                            /** @description The status of the organization registration, one of 'unregistered', 'registering', 'registered', and 'unknown' */
                            status?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSubscriptions: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                events?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                filters?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                options?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                transport?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putSubscription: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Server-side filter to apply to events */
                    filter?: {
                        /** @description Deprecated: Please use 'message.author' instead */
                        author?: string;
                        /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                        blockchainevent?: {
                            /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                            listener?: string;
                            /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                            name?: string;
                        };
                        /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                        events?: string;
                        /** @description Deprecated: Please use 'message.group' instead */
                        group?: string;
                        /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                        message?: {
                            /** @description Regular expression to apply to the message 'header.author' field */
                            author?: string;
                            /** @description Regular expression to apply to the message 'header.group' field */
                            group?: string;
                            /** @description Regular expression to apply to the message 'header.tag' field */
                            tag?: string;
                        };
                        /** @description Deprecated: Please use 'message.tag' instead */
                        tag?: string;
                        /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                        topic?: string;
                        /** @description Deprecated: Please use 'topic' instead */
                        topics?: string;
                        /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                        transaction?: {
                            /** @description Regular expression to apply to the transaction 'type' field */
                            type?: string;
                        };
                    };
                    /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                    name?: string;
                    /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                    namespace?: string;
                    /** @description Subscription options */
                    options?: {
                        /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                        batch?: boolean | null;
                        /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                        batchTimeout?: string | null;
                        /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                        fastack?: boolean;
                        /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                        firstEvent?: string | null;
                        /** @description Webhooks only: Static headers to set on the webhook request */
                        headers?: any;
                        /** @description Webhooks only: a set of options for HTTP */
                        httpOptions?: {
                            /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                            connectionTimeout?: string;
                            /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                            expectContinueTimeout?: string;
                            /** @description The max duration to hold a HTTP keepalive connection between calls */
                            idleTimeout?: string;
                            /** @description The max number of idle connections to hold pooled */
                            maxIdleConns?: number;
                            /** @description HTTP proxy URL to use for outbound requests to the webhook */
                            proxyURL?: string | null;
                            /** @description The max duration to hold a TLS handshake alive */
                            requestTimeout?: string;
                            /** @description The max duration to hold a TLS handshake alive */
                            tlsHandshakeTimeout?: string;
                        };
                        /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                        input?: {
                            /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                            body?: string;
                            /** @description A top-level property of the first data input, to use for headers */
                            headers?: string;
                            /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                            path?: string;
                            /** @description A top-level property of the first data input, to use for query parameters */
                            query?: string;
                            /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                            replytx?: string;
                        };
                        /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                        json?: boolean;
                        /** @description Webhooks only: HTTP method to invoke. Default=POST */
                        method?: string;
                        /** @description Webhooks only: Static query params to set on the webhook request */
                        query?: any;
                        /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                        readAhead?: number | null;
                        /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                        reply?: boolean;
                        /** @description Webhooks only: The tag to set on the reply message */
                        replytag?: string;
                        /** @description Webhooks only: The transaction type to set on the reply message */
                        replytx?: string;
                        /** @description Webhooks only: a set of options for retrying the webhook call */
                        retry?: {
                            /** @description Number of times to retry the webhook call in case of failure */
                            count?: number;
                            /** @description Enables retry on HTTP calls, defaults to false */
                            enabled?: boolean;
                            /** @description Initial delay between retries when we retry the webhook call */
                            initialDelay?: string;
                            /** @description Max delay between retries when we retry the webhookcall */
                            maxDelay?: string;
                        };
                        /** @description The name of an existing TLS configuration associated to the namespace to use */
                        tlsConfigName?: string;
                        /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                        url?: string;
                        /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                        withData?: boolean | null;
                    };
                    /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                    transport?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string | null;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postNewSubscription: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Server-side filter to apply to events */
                    filter?: {
                        /** @description Deprecated: Please use 'message.author' instead */
                        author?: string;
                        /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                        blockchainevent?: {
                            /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                            listener?: string;
                            /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                            name?: string;
                        };
                        /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                        events?: string;
                        /** @description Deprecated: Please use 'message.group' instead */
                        group?: string;
                        /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                        message?: {
                            /** @description Regular expression to apply to the message 'header.author' field */
                            author?: string;
                            /** @description Regular expression to apply to the message 'header.group' field */
                            group?: string;
                            /** @description Regular expression to apply to the message 'header.tag' field */
                            tag?: string;
                        };
                        /** @description Deprecated: Please use 'message.tag' instead */
                        tag?: string;
                        /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                        topic?: string;
                        /** @description Deprecated: Please use 'topic' instead */
                        topics?: string;
                        /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                        transaction?: {
                            /** @description Regular expression to apply to the transaction 'type' field */
                            type?: string;
                        };
                    };
                    /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                    name?: string;
                    /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                    namespace?: string;
                    /** @description Subscription options */
                    options?: {
                        /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                        batch?: boolean | null;
                        /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                        batchTimeout?: string | null;
                        /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                        fastack?: boolean;
                        /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                        firstEvent?: string | null;
                        /** @description Webhooks only: Static headers to set on the webhook request */
                        headers?: any;
                        /** @description Webhooks only: a set of options for HTTP */
                        httpOptions?: {
                            /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                            connectionTimeout?: string;
                            /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                            expectContinueTimeout?: string;
                            /** @description The max duration to hold a HTTP keepalive connection between calls */
                            idleTimeout?: string;
                            /** @description The max number of idle connections to hold pooled */
                            maxIdleConns?: number;
                            /** @description HTTP proxy URL to use for outbound requests to the webhook */
                            proxyURL?: string | null;
                            /** @description The max duration to hold a TLS handshake alive */
                            requestTimeout?: string;
                            /** @description The max duration to hold a TLS handshake alive */
                            tlsHandshakeTimeout?: string;
                        };
                        /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                        input?: {
                            /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                            body?: string;
                            /** @description A top-level property of the first data input, to use for headers */
                            headers?: string;
                            /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                            path?: string;
                            /** @description A top-level property of the first data input, to use for query parameters */
                            query?: string;
                            /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                            replytx?: string;
                        };
                        /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                        json?: boolean;
                        /** @description Webhooks only: HTTP method to invoke. Default=POST */
                        method?: string;
                        /** @description Webhooks only: Static query params to set on the webhook request */
                        query?: any;
                        /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                        readAhead?: number | null;
                        /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                        reply?: boolean;
                        /** @description Webhooks only: The tag to set on the reply message */
                        replytag?: string;
                        /** @description Webhooks only: The transaction type to set on the reply message */
                        replytx?: string;
                        /** @description Webhooks only: a set of options for retrying the webhook call */
                        retry?: {
                            /** @description Number of times to retry the webhook call in case of failure */
                            count?: number;
                            /** @description Enables retry on HTTP calls, defaults to false */
                            enabled?: boolean;
                            /** @description Initial delay between retries when we retry the webhook call */
                            initialDelay?: string;
                            /** @description Max delay between retries when we retry the webhookcall */
                            maxDelay?: string;
                        };
                        /** @description The name of an existing TLS configuration associated to the namespace to use */
                        tlsConfigName?: string;
                        /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                        url?: string;
                        /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                        withData?: boolean | null;
                    };
                    /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                    transport?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string | null;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSubscriptionByID: {
        parameters: {
            query?: {
                /** @description When set, the API will return additional status information if available */
                fetchstatus?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The subscription ID */
                subid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description Creation time of the subscription
                         */
                        created?: string | null;
                        /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
                        ephemeral?: boolean;
                        /** @description Server-side filter to apply to events */
                        filter?: {
                            /** @description Deprecated: Please use 'message.author' instead */
                            author?: string;
                            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                            blockchainevent?: {
                                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                listener?: string;
                                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                name?: string;
                            };
                            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                            events?: string;
                            /** @description Deprecated: Please use 'message.group' instead */
                            group?: string;
                            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                            message?: {
                                /** @description Regular expression to apply to the message 'header.author' field */
                                author?: string;
                                /** @description Regular expression to apply to the message 'header.group' field */
                                group?: string;
                                /** @description Regular expression to apply to the message 'header.tag' field */
                                tag?: string;
                            };
                            /** @description Deprecated: Please use 'message.tag' instead */
                            tag?: string;
                            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                            topic?: string;
                            /** @description Deprecated: Please use 'topic' instead */
                            topics?: string;
                            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                            transaction?: {
                                /** @description Regular expression to apply to the transaction 'type' field */
                                type?: string;
                            };
                        };
                        /**
                         * Format: uuid
                         * @description The UUID of the subscription
                         */
                        id?: string;
                        /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
                        name?: string;
                        /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
                        namespace?: string;
                        /** @description Subscription options */
                        options?: {
                            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch, allowing client-side optimizations when processing the events in a group. Available for both Webhooks and WebSockets. */
                            batch?: boolean | null;
                            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
                            batchTimeout?: string | null;
                            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
                            fastack?: boolean;
                            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
                            firstEvent?: string | null;
                            /** @description Webhooks only: Static headers to set on the webhook request */
                            headers?: any;
                            /** @description Webhooks only: a set of options for HTTP */
                            httpOptions?: {
                                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                                connectionTimeout?: string;
                                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                                expectContinueTimeout?: string;
                                /** @description The max duration to hold a HTTP keepalive connection between calls */
                                idleTimeout?: string;
                                /** @description The max number of idle connections to hold pooled */
                                maxIdleConns?: number;
                                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                                proxyURL?: string | null;
                                /** @description The max duration to hold a TLS handshake alive */
                                requestTimeout?: string;
                                /** @description The max duration to hold a TLS handshake alive */
                                tlsHandshakeTimeout?: string;
                            };
                            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
                            input?: {
                                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                                body?: string;
                                /** @description A top-level property of the first data input, to use for headers */
                                headers?: string;
                                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                                path?: string;
                                /** @description A top-level property of the first data input, to use for query parameters */
                                query?: string;
                                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                                replytx?: string;
                            };
                            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
                            json?: boolean;
                            /** @description Webhooks only: HTTP method to invoke. Default=POST */
                            method?: string;
                            /** @description Webhooks only: Static query params to set on the webhook request */
                            query?: any;
                            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
                            readAhead?: number | null;
                            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
                            reply?: boolean;
                            /** @description Webhooks only: The tag to set on the reply message */
                            replytag?: string;
                            /** @description Webhooks only: The transaction type to set on the reply message */
                            replytx?: string;
                            /** @description Webhooks only: a set of options for retrying the webhook call */
                            retry?: {
                                /** @description Number of times to retry the webhook call in case of failure */
                                count?: number;
                                /** @description Enables retry on HTTP calls, defaults to false */
                                enabled?: boolean;
                                /** @description Initial delay between retries when we retry the webhook call */
                                initialDelay?: string;
                                /** @description Max delay between retries when we retry the webhookcall */
                                maxDelay?: string;
                            };
                            /** @description The name of an existing TLS configuration associated to the namespace to use */
                            tlsConfigName?: string;
                            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
                            url?: string;
                            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
                            withData?: boolean | null;
                        };
                        /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
                        transport?: string;
                        /**
                         * Format: date-time
                         * @description Last time the subscription was updated
                         */
                        updated?: string | null;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteSubscription: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The subscription ID */
                subid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSubscriptionEventsFiltered: {
        parameters: {
            query?: {
                /** @description The sequence ID in the raw event stream to start indexing through events from. Leave blank to start indexing from the most recent events */
                startsequence?: string;
                /** @description The sequence ID in the raw event stream to stop indexing through events at. Leave blank to start indexing from the most recent events */
                endsequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                correlator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                reference?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                sequence?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                topic?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tx?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The subscription ID */
                subid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
                         */
                        correlator?: string | null;
                        /**
                         * Format: date-time
                         * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID assigned to this event by your local FireFly node
                         */
                        id?: string;
                        /** @description The namespace of the event. Your application must subscribe to events within a namespace */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
                         */
                        reference?: string | null;
                        /**
                         * Format: int64
                         * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
                         */
                        sequence?: number;
                        /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
                        topic?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
                         */
                        tx?: string | null;
                        /**
                         * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
                         * @enum {string}
                         */
                        type?: "transaction_submitted" | "message_confirmed" | "message_rejected" | "datatype_confirmed" | "identity_confirmed" | "identity_updated" | "token_pool_confirmed" | "token_pool_op_failed" | "token_transfer_confirmed" | "token_transfer_op_failed" | "token_approval_confirmed" | "token_approval_op_failed" | "contract_interface_confirmed" | "contract_api_confirmed" | "blockchain_event_received" | "blockchain_invoke_op_succeeded" | "blockchain_invoke_op_failed" | "blockchain_contract_deploy_op_succeeded" | "blockchain_contract_deploy_op_failed";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenAccounts: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain signing identity this balance applies to */
                        key?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenAccountPools: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The key for the token account. The exact format may vary based on the token connector use */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this balance entry applies to
                         */
                        pool?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenApprovals: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                active?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                approved?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainevent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                localid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                messagehash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                operator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                protocolid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                subject?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
                        active?: boolean;
                        /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                        approved?: boolean;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the token approval
                         */
                        created?: string | null;
                        /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token approval, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the approval, which must match the namespace of the token pool */
                        namespace?: string;
                        /** @description The blockchain identity that is granted the approval */
                        operator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this approval applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
                        subject?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenApproval: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                    approved?: boolean;
                    /** @description Input only field, with token connector specific configuration of the approval.  See your chosen token connector documentation for details */
                    config?: any;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the approval, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the approval */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The blockchain identity that is granted the approval */
                    operator?: string;
                    /**
                     * Format: uuid
                     * @description The UUID the token pool this approval applies to
                     */
                    pool?: string | null;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
                        active?: boolean;
                        /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                        approved?: boolean;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the token approval
                         */
                        created?: string | null;
                        /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token approval, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the approval, which must match the namespace of the token pool */
                        namespace?: string;
                        /** @description The blockchain identity that is granted the approval */
                        operator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this approval applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
                        subject?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
                        active?: boolean;
                        /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
                        approved?: boolean;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the token approval
                         */
                        created?: string | null;
                        /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token approval, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the approval, which must match the namespace of the token pool */
                        namespace?: string;
                        /** @description The blockchain identity that is granted the approval */
                        operator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this approval applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
                        subject?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenBalances: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                balance?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tokenindex?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                updated?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                uri?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The numeric balance. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when interpreting the balance. For example, with 18 decimals a fractional balance of 10.234 will be returned as 10,234,000,000,000,000,000 */
                        balance?: string;
                        /** @description The token connector that is responsible for the token pool of this balance entry */
                        connector?: string;
                        /** @description The blockchain signing identity this balance applies to */
                        key?: string;
                        /** @description The namespace of the token pool for this balance entry */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this balance entry applies to
                         */
                        pool?: string | null;
                        /** @description The index of the token within the pool that this balance applies to */
                        tokenIndex?: string;
                        /**
                         * Format: date-time
                         * @description The last time the balance was updated by applying a transfer event
                         */
                        updated?: string | null;
                        /** @description The URI of the token this balance entry applies to */
                        uri?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenBurn: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                    amount?: string;
                    /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description The source account for the transfer. On input defaults to the value of 'key' */
                    from?: string;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The name or UUID of a token pool */
                    pool?: string;
                    /** @description The index of the token within the pool that this transfer applies to */
                    tokenIndex?: string;
                    /** @description The URI of the token this transfer applies to */
                    uri?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenConnectors: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The name of the token connector, as configured in the FireFly core configuration file */
                        name?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenMint: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                    amount?: string;
                    /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The name or UUID of a token pool */
                    pool?: string;
                    /** @description The target account for the transfer. On input defaults to the value of 'key' */
                    to?: string;
                    /** @description The index of the token within the pool that this transfer applies to */
                    tokenIndex?: string;
                    /** @description The URI of the token this transfer applies to */
                    uri?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenPools: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                active?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                decimals?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interface?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                interfaceformat?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                locator?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                name?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                networkname?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                published?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                standard?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                symbol?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenPool: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
                /** @description When true the definition will be published to all other members of the multiparty network */
                publish?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Input only field, with token connector specific configuration of the pool, such as an existing Ethereum address and block number to used to index the pool. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                    connector?: string;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                    interface?: {
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly interface
                         */
                        id?: string | null;
                        /** @description The name of the FireFly interface */
                        name?: string;
                        /** @description The version of the FireFly interface */
                        version?: string;
                    } | null;
                    /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                    key?: string;
                    /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                    name?: string;
                    /** @description The published name of the token pool within the multiparty network */
                    networkName?: string;
                    /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                    symbol?: string;
                    /**
                     * @description The type of token the pool contains, such as fungible/non-fungible
                     * @enum {string}
                     */
                    type?: "fungible" | "nonfungible";
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenPoolByNameOrID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token pool name or ID */
                nameOrId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteTokenPool: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token pool name or ID */
                nameOrId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenPoolPublish: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token pool name or ID */
                nameOrId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
                    networkName?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Indicates whether the pool has been successfully activated with the token connector */
                        active?: boolean;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the pool
                         */
                        created?: string | null;
                        /** @description Number of decimal places that this token has */
                        decimals?: number;
                        /**
                         * Format: uuid
                         * @description The UUID of the token pool
                         */
                        id?: string | null;
                        /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
                        info?: any;
                        /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
                        interface?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly interface
                             */
                            id?: string | null;
                            /** @description The name of the FireFly interface */
                            name?: string;
                            /** @description The version of the FireFly interface */
                            version?: string;
                        } | null;
                        /**
                         * @description The interface encoding format supported by the connector for this token pool
                         * @enum {string}
                         */
                        interfaceFormat?: "abi" | "ffi";
                        /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
                        key?: string;
                        /** @description A unique identifier for the pool, as provided by the token connector */
                        locator?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the broadcast message used to inform the network about this pool
                         */
                        message?: string | null;
                        /** @description The method definitions resolved by the token connector to be used by each token operation */
                        methods?: any;
                        /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
                        name?: string;
                        /** @description The namespace for the token pool */
                        namespace?: string;
                        /** @description The published name of the token pool within the multiparty network */
                        networkName?: string;
                        /** @description Indicates if the token pool is published to other members of the multiparty network */
                        published?: boolean;
                        /** @description The ERC standard the token pool conforms to, as reported by the token connector */
                        standard?: string;
                        /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
                        symbol?: string;
                        /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of token the pool contains, such as fungible/non-fungible
                         * @enum {string}
                         */
                        type?: "fungible" | "nonfungible";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenTransfers: {
        parameters: {
            query?: {
                /** @description The sending or receiving token account for a token transfer */
                fromOrTo?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                amount?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainevent?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                connector?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                from?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                key?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                localid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                message?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                messagehash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                pool?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                protocolid?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                to?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                tokenindex?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.id"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                "tx.type"?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                uri?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postTokenTransfer: {
        parameters: {
            query?: {
                /** @description When true the HTTP request blocks until the message is confirmed */
                confirm?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                    amount?: string;
                    /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
                    config?: any;
                    /** @description The source account for the transfer. On input defaults to the value of 'key' */
                    from?: string;
                    /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
                    idempotencyKey?: string;
                    /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                    key?: string;
                    /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
                    message?: {
                        /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
                        data?: {
                            /** @description The optional datatype to use for validation of the in-line data */
                            datatype?: {
                                /** @description The name of the datatype */
                                name?: string;
                                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                                version?: string;
                            } | null;
                            /**
                             * Format: uuid
                             * @description The UUID of the referenced data resource
                             */
                            id?: string | null;
                            /** @description The data validator type to use for in-line data */
                            validator?: string;
                            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
                            value?: any;
                        }[];
                        /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
                        group?: {
                            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
                            members?: {
                                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                                identity?: string;
                                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                                node?: string;
                            }[];
                            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
                            name?: string;
                        } | null;
                        /** @description The message header contains all fields that are used to build the message hash */
                        header?: {
                            /** @description The DID of identity of the submitter */
                            author?: string;
                            /**
                             * Format: uuid
                             * @description The correlation ID of the message. Set this when a message is a response to another message
                             */
                            cid?: string | null;
                            /**
                             * Format: byte
                             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
                             */
                            group?: string | null;
                            /** @description The on-chain signing key used to sign the transaction */
                            key?: string;
                            /** @description The message tag indicates the purpose of the message to the applications that process it */
                            tag?: string;
                            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
                            topics?: string[];
                            /**
                             * @description The type of transaction used to order/deliver this message
                             * @enum {string}
                             */
                            txtype?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                            /**
                             * @description The type of the message
                             * @enum {string}
                             */
                            type?: "definition" | "broadcast" | "private" | "groupinit" | "transfer_broadcast" | "transfer_private" | "approval_broadcast" | "approval_private";
                        };
                        /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
                        idempotencyKey?: string;
                    } | null;
                    /** @description The name or UUID of a token pool */
                    pool?: string;
                    /** @description The target account for the transfer. On input defaults to the value of 'key' */
                    to?: string;
                    /** @description The index of the token within the pool that this transfer applies to */
                    tokenIndex?: string;
                    /** @description The URI of the token this transfer applies to */
                    uri?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            /** @description Success */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string | null;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenTransferByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The token transfer ID */
                transferId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
                        amount?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the blockchain event
                         */
                        blockchainEvent?: string | null;
                        /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
                        connector?: string;
                        /**
                         * Format: date-time
                         * @description The creation time of the transfer
                         */
                        created?: string | null;
                        /** @description The source account for the transfer. On input defaults to the value of 'key' */
                        from?: string;
                        /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
                        key?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of this token transfer, in the local FireFly node
                         */
                        localId?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        message?: string | null;
                        /**
                         * Format: byte
                         * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
                         */
                        messageHash?: string | null;
                        /** @description The namespace for the transfer, which must match the namespace of the token pool */
                        namespace?: string;
                        /**
                         * Format: uuid
                         * @description The UUID the token pool this transfer applies to
                         */
                        pool?: string | null;
                        /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
                        protocolId?: string;
                        /** @description The target account for the transfer. On input defaults to the value of 'key' */
                        to?: string;
                        /** @description The index of the token within the pool that this transfer applies to */
                        tokenIndex?: string;
                        /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
                        tx?: {
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                        /**
                         * @description The type of transfer such as mint/burn/transfer
                         * @enum {string}
                         */
                        type?: "mint" | "burn" | "transfer";
                        /** @description The URI of the token this transfer applies to */
                        uri?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxns: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainids?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
                        blockchainIds?: string[];
                        /**
                         * Format: date-time
                         * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction
                         */
                        id?: string;
                        /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
                        idempotencyKey?: string;
                        /** @description The namespace of the FireFly transaction */
                        namespace?: string;
                        /**
                         * @description The type of the FireFly transaction
                         * @enum {string}
                         */
                        type?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnByID: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                blockchainids?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                id?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                idempotencykey?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
                        blockchainIds?: string[];
                        /**
                         * Format: date-time
                         * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
                         */
                        created?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction
                         */
                        id?: string;
                        /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
                        idempotencyKey?: string;
                        /** @description The namespace of the FireFly transaction */
                        namespace?: string;
                        /**
                         * @description The type of the FireFly transaction
                         * @enum {string}
                         */
                        type?: "none" | "unpinned" | "batch_pin" | "network_action" | "token_pool" | "token_transfer" | "contract_deploy" | "contract_invoke" | "contract_invoke_pin" | "token_approval" | "data_publish";
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnBlockchainEvents: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: uuid
                         * @description The UUID assigned to the event by FireFly
                         */
                        id?: string;
                        /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
                        info?: any;
                        /**
                         * Format: uuid
                         * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
                         */
                        listener?: string | null;
                        /** @description The name of the event in the blockchain smart contract */
                        name?: string;
                        /** @description The namespace of the listener that detected this blockchain event */
                        namespace?: string;
                        /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
                        output?: any;
                        /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
                        protocolId?: string;
                        /** @description The blockchain plugin or token service that detected the event */
                        source?: string;
                        /**
                         * Format: date-time
                         * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
                         */
                        timestamp?: string | null;
                        /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
                        tx?: {
                            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
                            blockchainId?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the FireFly transaction
                             */
                            id?: string;
                            /** @description The type of the FireFly transaction */
                            type?: string;
                        };
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnOps: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time the operation was created
                         */
                        created?: string | null;
                        /** @description Any error reported back from the plugin for this operation */
                        error?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the operation
                         */
                        id?: string;
                        /** @description The input to this operation */
                        input?: any;
                        /** @description The namespace of the operation */
                        namespace?: string;
                        /** @description Any output reported back from the plugin for this operation */
                        output?: any;
                        /** @description The plugin responsible for performing the operation */
                        plugin?: string;
                        /**
                         * Format: uuid
                         * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
                         */
                        retry?: string | null;
                        /** @description The current status of the operation */
                        status?: string;
                        /**
                         * Format: uuid
                         * @description The UUID of the FireFly transaction the operation is part of
                         */
                        tx?: string | null;
                        /**
                         * @description The type of the operation
                         * @enum {string}
                         */
                        type?: "blockchain_pin_batch" | "blockchain_network_action" | "blockchain_deploy" | "blockchain_invoke" | "sharedstorage_upload_batch" | "sharedstorage_upload_blob" | "sharedstorage_upload_value" | "sharedstorage_download_batch" | "sharedstorage_download_blob" | "dataexchange_send_batch" | "dataexchange_send_blob" | "token_create_pool" | "token_activate_pool" | "token_transfer" | "token_approval";
                        /**
                         * Format: date-time
                         * @description The last update time of the operation
                         */
                        updated?: string | null;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTxnStatus: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The transaction ID */
                txnid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A set of records describing the activities within the transaction known by the local FireFly node */
                        details?: {
                            /** @description If an error occurred related to the detail entry, it is included here */
                            error?: string;
                            /**
                             * Format: uuid
                             * @description The UUID of the entry referenced by this detail. The type of this record can be inferred from the entry type
                             */
                            id?: string;
                            /** @description Output details for this entry */
                            info?: any;
                            /** @description The status of the detail record. Cases where an event is required for completion, but has not arrived yet are marked with a 'pending' record */
                            status?: string;
                            /** @description A sub-type, such as an operation type, or an event type */
                            subtype?: string;
                            /**
                             * Format: date-time
                             * @description The time relevant to when the record was updated, such as the time an event was created, or the last update time of an operation
                             */
                            timestamp?: string | null;
                            /** @description The type of the transaction status detail record */
                            type?: string;
                        }[];
                        /** @description The overall computed status of the transaction, after analyzing the details during the API call */
                        status?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVerifiers: {
        parameters: {
            query?: {
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                created?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                hash?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                identity?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                type?: string;
                /** @description Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
                value?: string;
                /** @description Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
                sort?: string;
                /** @description Ascending sort order (overrides all fields in a multi-field sort) */
                ascending?: string;
                /** @description Descending sort order (overrides all fields in a multi-field sort) */
                descending?: string;
                /** @description The number of records to skip (max: 1,000). Unsuitable for bulk operations */
                skip?: string;
                /** @description The maximum number of records to return (max: 1,000) */
                limit?: string;
                /** @description Return a total count as well as items (adds extra database processing) */
                count?: string;
            };
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time this verifier was created on this node
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity that has claimed this verifier
                         */
                        identity?: string | null;
                        /** @description The namespace of the verifier */
                        namespace?: string;
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    }[];
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getVerifierByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path: {
                /** @description The hash of the verifier */
                hash: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: date-time
                         * @description The time this verifier was created on this node
                         */
                        created?: string | null;
                        /**
                         * Format: byte
                         * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
                         */
                        hash?: string | null;
                        /**
                         * Format: uuid
                         * @description The UUID of the parent identity that has claimed this verifier
                         */
                        identity?: string | null;
                        /** @description The namespace of the verifier */
                        namespace?: string;
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postVerifiersResolve: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * @description The type of the verifier
                     * @enum {string}
                     */
                    type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                    /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                    value?: string;
                };
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description The type of the verifier
                         * @enum {string}
                         */
                        type?: "ethereum_address" | "tezos_address" | "fabric_msp_id" | "dx_peer_id";
                        /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                        value?: string;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWebSockets: {
        parameters: {
            query?: never;
            header?: {
                /** @description Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
                "Request-Timeout"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of currently active websocket client connections */
                        connections?: {
                            /** @description The unique ID assigned to this client connection */
                            id?: string;
                            /** @description The remote address of the connected client (if available) */
                            remoteAddress?: string;
                            /** @description List of subscriptions currently started by this client */
                            subscriptions?: {
                                /** @description Indicates whether the subscription is ephemeral (vs durable) */
                                ephemeral?: boolean;
                                /** @description The subscription filter specification */
                                filter?: {
                                    /** @description Deprecated: Please use 'message.author' instead */
                                    author?: string;
                                    /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                                    blockchainevent?: {
                                        /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                                        listener?: string;
                                        /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                                        name?: string;
                                    };
                                    /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                                    events?: string;
                                    /** @description Deprecated: Please use 'message.group' instead */
                                    group?: string;
                                    /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                                    message?: {
                                        /** @description Regular expression to apply to the message 'header.author' field */
                                        author?: string;
                                        /** @description Regular expression to apply to the message 'header.group' field */
                                        group?: string;
                                        /** @description Regular expression to apply to the message 'header.tag' field */
                                        tag?: string;
                                    };
                                    /** @description Deprecated: Please use 'message.tag' instead */
                                    tag?: string;
                                    /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                                    topic?: string;
                                    /** @description Deprecated: Please use 'topic' instead */
                                    topics?: string;
                                    /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                                    transaction?: {
                                        /** @description Regular expression to apply to the transaction 'type' field */
                                        type?: string;
                                    };
                                };
                                /** @description The subscription name (for durable subscriptions only) */
                                name?: string;
                                /** @description The subscription namespace */
                                namespace?: string;
                                /**
                                 * Format: date-time
                                 * @description The time the subscription started (reset on dynamic namespace reload)
                                 */
                                startTime?: string | null;
                            }[];
                            /** @description The user agent of the connected client (if available) */
                            userAgent?: string;
                        }[];
                        /** @description Indicates whether the websockets plugin is enabled */
                        enabled?: boolean;
                    };
                };
            };
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
