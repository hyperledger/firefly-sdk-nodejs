/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/apis": {
    /** Gets a list of contract APIs that have been published */
    get: operations["getContractAPIs"];
    /** Creates and broadcasts a new custom smart contract API */
    post: operations["postNewContractAPI"];
  };
  "/apis/{apiName}": {
    /** Gets information about a contract API, including the URLs for the OpenAPI Spec and Swagger UI for the API */
    get: operations["getContractAPIByName"];
    /** Delete a contract API */
    delete: operations["deleteContractAPI"];
  };
  "/apis/{apiName}/interface": {
    /** Gets a contract interface for a contract API */
    get: operations["getContractAPIInterface"];
  };
  "/apis/{apiName}/invoke/{methodPath}": {
    /** Invokes a method on a smart contract API. Performs a blockchain transaction. */
    post: operations["postContractAPIInvoke"];
  };
  "/apis/{apiName}/listeners/{eventPath}": {
    /** Gets a list of contract listeners */
    get: operations["getContractAPIListeners"];
    /** Creates a new blockchain listener for events emitted by custom smart contracts */
    post: operations["postContractAPIListeners"];
  };
  "/apis/{apiName}/publish": {
    /** Publish a contract API to all other members of the multiparty network */
    post: operations["postContractAPIPublish"];
  };
  "/apis/{apiName}/query/{methodPath}": {
    /** Queries a method on a smart contract API. Performs a read-only query. */
    post: operations["postContractAPIQuery"];
  };
  "/apis/{id}": {
    /** The ID of the contract API */
    put: operations["putContractAPI"];
  };
  "/batches": {
    /** Gets a list of message batches */
    get: operations["getBatches"];
  };
  "/batches/{batchid}": {
    /** Gets a message batch */
    get: operations["getBatchByID"];
  };
  "/blockchainevents": {
    /** Gets a list of blockchain events */
    get: operations["getBlockchainEvents"];
  };
  "/blockchainevents/{id}": {
    /** Gets a blockchain event */
    get: operations["getBlockchainEventByID"];
  };
  "/charts/histogram/{collection}": {
    /** Gets a JSON object containing statistics data that can be used to build a graphical representation of recent activity in a given database collection */
    get: operations["getChartHistogram"];
  };
  "/contracts/deploy": {
    /** Deploy a new smart contract */
    post: operations["postContractDeploy"];
  };
  "/contracts/interfaces": {
    /** Gets a list of contract interfaces that have been published */
    get: operations["getContractInterfaces"];
    /** Creates and broadcasts a new custom smart contract interface */
    post: operations["postNewContractInterface"];
  };
  "/contracts/interfaces/{interfaceId}": {
    /** Gets a contract interface by its ID */
    get: operations["getContractInterface"];
    /** Delete a contract interface */
    delete: operations["deleteContractInterface"];
  };
  "/contracts/interfaces/{name}/{version}": {
    /** Gets a contract interface by its name and version */
    get: operations["getContractInterfaceByNameAndVersion"];
  };
  "/contracts/interfaces/{name}/{version}/publish": {
    /** Publish a contract interface to all other members of the multiparty network */
    post: operations["postContractInterfacePublish"];
  };
  "/contracts/interfaces/generate": {
    /** A convenience method to convert a blockchain specific smart contract format into a FireFly Interface format. The specific blockchain plugin in use must support this functionality. */
    post: operations["postGenerateContractInterface"];
  };
  "/contracts/invoke": {
    /** Invokes a method on a smart contract. Performs a blockchain transaction. */
    post: operations["postContractInvoke"];
  };
  "/contracts/listeners": {
    /** Gets a list of contract listeners */
    get: operations["getContractListeners"];
    /** Creates a new blockchain listener for events emitted by custom smart contracts */
    post: operations["postNewContractListener"];
  };
  "/contracts/listeners/{nameOrId}": {
    /** Gets a contract listener by its name or ID */
    get: operations["getContractListenerByNameOrID"];
    /** Deletes a contract listener referenced by its name or its ID */
    delete: operations["deleteContractListener"];
  };
  "/contracts/query": {
    /** Queries a method on a smart contract. Performs a read-only query. */
    post: operations["postContractQuery"];
  };
  "/data": {
    /** Gets a list of data items */
    get: operations["getData"];
    /** Creates a new data item in this FireFly node */
    post: operations["postData"];
  };
  "/data/{dataid}": {
    /** Gets a data item by its ID, including metadata about this item */
    get: operations["getDataByID"];
    /** Deletes a data item by its ID, including metadata about this item */
    delete: operations["deleteData"];
  };
  "/data/{dataid}/blob": {
    /** Downloads the original file that was previously uploaded or received */
    get: operations["getDataBlob"];
  };
  "/data/{dataid}/blob/publish": {
    /** Publishes the binary blob attachment stored in your local data exchange, to shared storage */
    post: operations["postDataBlobPublish"];
  };
  "/data/{dataid}/messages": {
    /** Gets a list of the messages associated with a data item */
    get: operations["getDataMsgs"];
  };
  "/data/{dataid}/value": {
    /** Downloads the JSON value of the data resource, without the associated metadata */
    get: operations["getDataValue"];
  };
  "/data/{dataid}/value/publish": {
    /** Publishes the JSON value from the specified data resource, to shared storage */
    post: operations["postDataValuePublish"];
  };
  "/datasubpaths/{parent}": {
    /** Gets a list of path names of named blob data, underneath a given parent path ('/' path prefixes are automatically pre-prepended) */
    get: operations["getDataSubPaths"];
  };
  "/datatypes": {
    /** Gets a list of datatypes that have been published */
    get: operations["getDatatypes"];
    /** Creates and broadcasts a new datatype */
    post: operations["postNewDatatype"];
  };
  "/datatypes/{name}/{version}": {
    /** Gets a datatype by its name and version */
    get: operations["getDatatypeByName"];
  };
  "/events": {
    /** Gets a list of events */
    get: operations["getEvents"];
  };
  "/events/{eid}": {
    /** Gets an event by its ID */
    get: operations["getEventByID"];
  };
  "/groups": {
    /** Gets a list of groups */
    get: operations["getGroups"];
  };
  "/groups/{hash}": {
    /** Gets a group by its ID (hash) */
    get: operations["getGroupByHash"];
  };
  "/identities": {
    /** Gets a list of all identities that have been registered in the namespace */
    get: operations["getIdentities"];
    /** Registers a new identity in the network */
    post: operations["postNewIdentity"];
  };
  "/identities/{did}": {
    /** Gets an identity by its DID */
    get: operations["getIdentityByDID"];
  };
  "/identities/{iid}": {
    /** Gets an identity by its ID */
    get: operations["getIdentityByID"];
    /** Updates an identity */
    patch: operations["patchUpdateIdentity"];
  };
  "/identities/{iid}/did": {
    /** Gets the DID for an identity based on its ID */
    get: operations["getIdentityDID"];
  };
  "/identities/{iid}/verifiers": {
    /** Gets the verifiers for an identity */
    get: operations["getIdentityVerifiers"];
  };
  "/messages": {
    /** Gets a list of messages */
    get: operations["getMsgs"];
  };
  "/messages/{msgid}": {
    /** Gets a message by its ID */
    get: operations["getMsgByID"];
  };
  "/messages/{msgid}/data": {
    /** Gets the list of data items that are attached to a message */
    get: operations["getMsgData"];
  };
  "/messages/{msgid}/events": {
    /** Gets the list of events for a message */
    get: operations["getMsgEvents"];
  };
  "/messages/{msgid}/transaction": {
    /** Gets the transaction for a message */
    get: operations["getMsgTxn"];
  };
  "/messages/broadcast": {
    /** Broadcasts a message to all members in the network */
    post: operations["postNewMessageBroadcast"];
  };
  "/messages/private": {
    /** Privately sends a message to one or more members in the network */
    post: operations["postNewMessagePrivate"];
  };
  "/messages/requestreply": {
    /** Sends a message with a blocking HTTP request, waits for a reply to that message, then sends the reply as the HTTP response. */
    post: operations["postNewMessageRequestReply"];
  };
  "/namespaces": {
    /** Gets a list of namespaces */
    get: operations["getNamespaces"];
  };
  "/namespaces/{ns}": {
    /** Gets a namespace */
    get: operations["getNamespace"];
  };
  "/namespaces/{ns}/apis": {
    /** Gets a list of contract APIs that have been published */
    get: operations["getContractAPIsNamespace"];
    /** Creates and broadcasts a new custom smart contract API */
    post: operations["postNewContractAPINamespace"];
  };
  "/namespaces/{ns}/apis/{apiName}": {
    /** Gets information about a contract API, including the URLs for the OpenAPI Spec and Swagger UI for the API */
    get: operations["getContractAPIByNameNamespace"];
    /** Delete a contract API */
    delete: operations["deleteContractAPINamespace"];
  };
  "/namespaces/{ns}/apis/{apiName}/interface": {
    /** Gets a contract interface for a contract API */
    get: operations["getContractAPIInterfaceNamespace"];
  };
  "/namespaces/{ns}/apis/{apiName}/invoke/{methodPath}": {
    /** Invokes a method on a smart contract API. Performs a blockchain transaction. */
    post: operations["postContractAPIInvokeNamespace"];
  };
  "/namespaces/{ns}/apis/{apiName}/listeners/{eventPath}": {
    /** Gets a list of contract listeners */
    get: operations["getContractAPIListenersNamespace"];
    /** Creates a new blockchain listener for events emitted by custom smart contracts */
    post: operations["postContractAPIListenersNamespace"];
  };
  "/namespaces/{ns}/apis/{apiName}/publish": {
    /** Publish a contract API to all other members of the multiparty network */
    post: operations["postContractAPIPublishNamespace"];
  };
  "/namespaces/{ns}/apis/{apiName}/query/{methodPath}": {
    /** Queries a method on a smart contract API. Performs a read-only query. */
    post: operations["postContractAPIQueryNamespace"];
  };
  "/namespaces/{ns}/apis/{id}": {
    /** The ID of the contract API */
    put: operations["putContractAPINamespace"];
  };
  "/namespaces/{ns}/batches": {
    /** Gets a list of message batches */
    get: operations["getBatchesNamespace"];
  };
  "/namespaces/{ns}/batches/{batchid}": {
    /** Gets a message batch */
    get: operations["getBatchByIDNamespace"];
  };
  "/namespaces/{ns}/blockchainevents": {
    /** Gets a list of blockchain events */
    get: operations["getBlockchainEventsNamespace"];
  };
  "/namespaces/{ns}/blockchainevents/{id}": {
    /** Gets a blockchain event */
    get: operations["getBlockchainEventByIDNamespace"];
  };
  "/namespaces/{ns}/charts/histogram/{collection}": {
    /** Gets a JSON object containing statistics data that can be used to build a graphical representation of recent activity in a given database collection */
    get: operations["getChartHistogramNamespace"];
  };
  "/namespaces/{ns}/contracts/deploy": {
    /** Deploy a new smart contract */
    post: operations["postContractDeployNamespace"];
  };
  "/namespaces/{ns}/contracts/interfaces": {
    /** Gets a list of contract interfaces that have been published */
    get: operations["getContractInterfacesNamespace"];
    /** Creates and broadcasts a new custom smart contract interface */
    post: operations["postNewContractInterfaceNamespace"];
  };
  "/namespaces/{ns}/contracts/interfaces/{interfaceId}": {
    /** Gets a contract interface by its ID */
    get: operations["getContractInterfaceNamespace"];
    /** Delete a contract interface */
    delete: operations["deleteContractInterfaceNamespace"];
  };
  "/namespaces/{ns}/contracts/interfaces/{name}/{version}": {
    /** Gets a contract interface by its name and version */
    get: operations["getContractInterfaceByNameAndVersionNamespace"];
  };
  "/namespaces/{ns}/contracts/interfaces/{name}/{version}/publish": {
    /** Publish a contract interface to all other members of the multiparty network */
    post: operations["postContractInterfacePublishNamespace"];
  };
  "/namespaces/{ns}/contracts/interfaces/generate": {
    /** A convenience method to convert a blockchain specific smart contract format into a FireFly Interface format. The specific blockchain plugin in use must support this functionality. */
    post: operations["postGenerateContractInterfaceNamespace"];
  };
  "/namespaces/{ns}/contracts/invoke": {
    /** Invokes a method on a smart contract. Performs a blockchain transaction. */
    post: operations["postContractInvokeNamespace"];
  };
  "/namespaces/{ns}/contracts/listeners": {
    /** Gets a list of contract listeners */
    get: operations["getContractListenersNamespace"];
    /** Creates a new blockchain listener for events emitted by custom smart contracts */
    post: operations["postNewContractListenerNamespace"];
  };
  "/namespaces/{ns}/contracts/listeners/{nameOrId}": {
    /** Gets a contract listener by its name or ID */
    get: operations["getContractListenerByNameOrIDNamespace"];
    /** Deletes a contract listener referenced by its name or its ID */
    delete: operations["deleteContractListenerNamespace"];
  };
  "/namespaces/{ns}/contracts/query": {
    /** Queries a method on a smart contract. Performs a read-only query. */
    post: operations["postContractQueryNamespace"];
  };
  "/namespaces/{ns}/data": {
    /** Gets a list of data items */
    get: operations["getDataNamespace"];
    /** Creates a new data item in this FireFly node */
    post: operations["postDataNamespace"];
  };
  "/namespaces/{ns}/data/{dataid}": {
    /** Gets a data item by its ID, including metadata about this item */
    get: operations["getDataByIDNamespace"];
    /** Deletes a data item by its ID, including metadata about this item */
    delete: operations["deleteDataNamespace"];
  };
  "/namespaces/{ns}/data/{dataid}/blob": {
    /** Downloads the original file that was previously uploaded or received */
    get: operations["getDataBlobNamespace"];
  };
  "/namespaces/{ns}/data/{dataid}/blob/publish": {
    /** Publishes the binary blob attachment stored in your local data exchange, to shared storage */
    post: operations["postDataBlobPublishNamespace"];
  };
  "/namespaces/{ns}/data/{dataid}/messages": {
    /** Gets a list of the messages associated with a data item */
    get: operations["getDataMsgsNamespace"];
  };
  "/namespaces/{ns}/data/{dataid}/value": {
    /** Downloads the JSON value of the data resource, without the associated metadata */
    get: operations["getDataValueNamespace"];
  };
  "/namespaces/{ns}/data/{dataid}/value/publish": {
    /** Publishes the JSON value from the specified data resource, to shared storage */
    post: operations["postDataValuePublishNamespace"];
  };
  "/namespaces/{ns}/datasubpaths/{parent}": {
    /** Gets a list of path names of named blob data, underneath a given parent path ('/' path prefixes are automatically pre-prepended) */
    get: operations["getDataSubPathsNamespace"];
  };
  "/namespaces/{ns}/datatypes": {
    /** Gets a list of datatypes that have been published */
    get: operations["getDatatypesNamespace"];
    /** Creates and broadcasts a new datatype */
    post: operations["postNewDatatypeNamespace"];
  };
  "/namespaces/{ns}/datatypes/{name}/{version}": {
    /** Gets a datatype by its name and version */
    get: operations["getDatatypeByNameNamespace"];
  };
  "/namespaces/{ns}/events": {
    /** Gets a list of events */
    get: operations["getEventsNamespace"];
  };
  "/namespaces/{ns}/events/{eid}": {
    /** Gets an event by its ID */
    get: operations["getEventByIDNamespace"];
  };
  "/namespaces/{ns}/groups": {
    /** Gets a list of groups */
    get: operations["getGroupsNamespace"];
  };
  "/namespaces/{ns}/groups/{hash}": {
    /** Gets a group by its ID (hash) */
    get: operations["getGroupByHashNamespace"];
  };
  "/namespaces/{ns}/identities": {
    /** Gets a list of all identities that have been registered in the namespace */
    get: operations["getIdentitiesNamespace"];
    /** Registers a new identity in the network */
    post: operations["postNewIdentityNamespace"];
  };
  "/namespaces/{ns}/identities/{did}": {
    /** Gets an identity by its DID */
    get: operations["getIdentityByDIDNamespace"];
  };
  "/namespaces/{ns}/identities/{iid}": {
    /** Gets an identity by its ID */
    get: operations["getIdentityByIDNamespace"];
    /** Updates an identity */
    patch: operations["patchUpdateIdentityNamespace"];
  };
  "/namespaces/{ns}/identities/{iid}/did": {
    /** Gets the DID for an identity based on its ID */
    get: operations["getIdentityDIDNamespace"];
  };
  "/namespaces/{ns}/identities/{iid}/verifiers": {
    /** Gets the verifiers for an identity */
    get: operations["getIdentityVerifiersNamespace"];
  };
  "/namespaces/{ns}/messages": {
    /** Gets a list of messages */
    get: operations["getMsgsNamespace"];
  };
  "/namespaces/{ns}/messages/{msgid}": {
    /** Gets a message by its ID */
    get: operations["getMsgByIDNamespace"];
  };
  "/namespaces/{ns}/messages/{msgid}/data": {
    /** Gets the list of data items that are attached to a message */
    get: operations["getMsgDataNamespace"];
  };
  "/namespaces/{ns}/messages/{msgid}/events": {
    /** Gets the list of events for a message */
    get: operations["getMsgEventsNamespace"];
  };
  "/namespaces/{ns}/messages/{msgid}/transaction": {
    /** Gets the transaction for a message */
    get: operations["getMsgTxnNamespace"];
  };
  "/namespaces/{ns}/messages/broadcast": {
    /** Broadcasts a message to all members in the network */
    post: operations["postNewMessageBroadcastNamespace"];
  };
  "/namespaces/{ns}/messages/private": {
    /** Privately sends a message to one or more members in the network */
    post: operations["postNewMessagePrivateNamespace"];
  };
  "/namespaces/{ns}/messages/requestreply": {
    /** Sends a message with a blocking HTTP request, waits for a reply to that message, then sends the reply as the HTTP response. */
    post: operations["postNewMessageRequestReplyNamespace"];
  };
  "/namespaces/{ns}/network/action": {
    /** Notify all nodes in the network of a new governance action */
    post: operations["postNetworkActionNamespace"];
  };
  "/namespaces/{ns}/network/diddocs/{did}": {
    /** Gets a DID document by its DID */
    get: operations["getNetworkDIDDocByDIDNamespace"];
  };
  "/namespaces/{ns}/network/identities": {
    /** Gets the list of identities in the network (deprecated - use /identities instead of /network/identities */
    get: operations["getNetworkIdentitiesNamespace"];
  };
  "/namespaces/{ns}/network/identities/{did}": {
    /** Gets an identity by its DID */
    get: operations["getNetworkIdentityByDIDNamespace"];
  };
  "/namespaces/{ns}/network/nodes": {
    /** Gets a list of nodes in the network */
    get: operations["getNetworkNodesNamespace"];
  };
  "/namespaces/{ns}/network/nodes/{nameOrId}": {
    /** Gets information about a specific node in the network */
    get: operations["getNetworkNodeNamespace"];
  };
  "/namespaces/{ns}/network/nodes/self": {
    /** Instructs this FireFly node to register itself on the network */
    post: operations["postNodesSelfNamespace"];
  };
  "/namespaces/{ns}/network/organizations": {
    /** Gets a list of orgs in the network */
    get: operations["getNetworkOrgsNamespace"];
    /** Registers a new org in the network */
    post: operations["postNewOrganizationNamespace"];
  };
  "/namespaces/{ns}/network/organizations/{nameOrId}": {
    /** Gets information about a specific org in the network */
    get: operations["getNetworkOrgNamespace"];
  };
  "/namespaces/{ns}/network/organizations/self": {
    /** Instructs this FireFly node to register its org on the network */
    post: operations["postNewOrganizationSelfNamespace"];
  };
  "/namespaces/{ns}/nextpins": {
    /** Queries the list of next-pins that determine the next masked message sequence for each member of a privacy group, on each context/topic */
    get: operations["getNextPinsNamespace"];
  };
  "/namespaces/{ns}/operations": {
    /** Gets a a list of operations */
    get: operations["getOpsNamespace"];
  };
  "/namespaces/{ns}/operations/{opid}": {
    /** Gets an operation by ID */
    get: operations["getOpByIDNamespace"];
  };
  "/namespaces/{ns}/operations/{opid}/retry": {
    /** Retries a failed operation */
    post: operations["postOpRetryNamespace"];
  };
  "/namespaces/{ns}/pins": {
    /** Queries the list of pins received from the blockchain */
    get: operations["getPinsNamespace"];
  };
  "/namespaces/{ns}/pins/rewind": {
    /** Force a rewind of the event aggregator to a previous position, to re-evaluate (and possibly dispatch) that pin and others after it. Only accepts a sequence or batch ID for a currently undispatched pin */
    post: operations["postPinsRewindNamespace"];
  };
  "/namespaces/{ns}/status": {
    /** Gets the status of this namespace */
    get: operations["getStatusNamespace"];
  };
  "/namespaces/{ns}/status/batchmanager": {
    /** Gets the status of the batch manager */
    get: operations["getStatusBatchManagerNamespace"];
  };
  "/namespaces/{ns}/subscriptions": {
    /** Gets a list of subscriptions */
    get: operations["getSubscriptionsNamespace"];
    /** Update an existing subscription */
    put: operations["putSubscriptionNamespace"];
    /** Creates a new subscription for an application to receive events from FireFly */
    post: operations["postNewSubscriptionNamespace"];
  };
  "/namespaces/{ns}/subscriptions/{subid}": {
    /** Gets a subscription by its ID */
    get: operations["getSubscriptionByIDNamespace"];
    /** Deletes a subscription */
    delete: operations["deleteSubscriptionNamespace"];
  };
  "/namespaces/{ns}/tokens/accounts": {
    /** Gets a list of token accounts */
    get: operations["getTokenAccountsNamespace"];
  };
  "/namespaces/{ns}/tokens/accounts/{key}/pools": {
    /** Gets a list of token pools that contain a given token account key */
    get: operations["getTokenAccountPoolsNamespace"];
  };
  "/namespaces/{ns}/tokens/approvals": {
    /** Gets a list of token approvals */
    get: operations["getTokenApprovalsNamespace"];
    /** Creates a token approval */
    post: operations["postTokenApprovalNamespace"];
  };
  "/namespaces/{ns}/tokens/balances": {
    /** Gets a list of token balances */
    get: operations["getTokenBalancesNamespace"];
  };
  "/namespaces/{ns}/tokens/burn": {
    /** Burns some tokens */
    post: operations["postTokenBurnNamespace"];
  };
  "/namespaces/{ns}/tokens/connectors": {
    /** Gets the list of token connectors currently in use */
    get: operations["getTokenConnectorsNamespace"];
  };
  "/namespaces/{ns}/tokens/mint": {
    /** Mints some tokens */
    post: operations["postTokenMintNamespace"];
  };
  "/namespaces/{ns}/tokens/pools": {
    /** Gets a list of token pools */
    get: operations["getTokenPoolsNamespace"];
    /** Creates a new token pool */
    post: operations["postTokenPoolNamespace"];
  };
  "/namespaces/{ns}/tokens/pools/{nameOrId}": {
    /** Gets a token pool by its name or its ID */
    get: operations["getTokenPoolByNameOrIDNamespace"];
    /** Delete a token pool */
    delete: operations["deleteTokenPoolNamespace"];
  };
  "/namespaces/{ns}/tokens/pools/{nameOrId}/publish": {
    /** Publish a token pool to all other members of the multiparty network */
    post: operations["postTokenPoolPublishNamespace"];
  };
  "/namespaces/{ns}/tokens/transfers": {
    /** Gets a list of token transfers */
    get: operations["getTokenTransfersNamespace"];
    /** Transfers some tokens */
    post: operations["postTokenTransferNamespace"];
  };
  "/namespaces/{ns}/tokens/transfers/{transferId}": {
    /** Gets a token transfer by its ID */
    get: operations["getTokenTransferByIDNamespace"];
  };
  "/namespaces/{ns}/transactions": {
    /** Gets a list of transactions */
    get: operations["getTxnsNamespace"];
  };
  "/namespaces/{ns}/transactions/{txnid}": {
    /** Gets a transaction by its ID */
    get: operations["getTxnByIDNamespace"];
  };
  "/namespaces/{ns}/transactions/{txnid}/blockchainevents": {
    /** Gets a list blockchain events for a specific transaction */
    get: operations["getTxnBlockchainEventsNamespace"];
  };
  "/namespaces/{ns}/transactions/{txnid}/operations": {
    /** Gets a list of operations in a specific transaction */
    get: operations["getTxnOpsNamespace"];
  };
  "/namespaces/{ns}/transactions/{txnid}/status": {
    /** Gets the status of a transaction */
    get: operations["getTxnStatusNamespace"];
  };
  "/namespaces/{ns}/verifiers": {
    /** Gets a list of verifiers */
    get: operations["getVerifiersNamespace"];
  };
  "/namespaces/{ns}/verifiers/{hash}": {
    /** Gets a verifier by its hash */
    get: operations["getVerifierByIDNamespace"];
  };
  "/namespaces/{ns}/verifiers/resolve": {
    /** Resolves an input key to a signing key */
    post: operations["postVerifiersResolveNamespace"];
  };
  "/network/action": {
    /** Notify all nodes in the network of a new governance action */
    post: operations["postNetworkAction"];
  };
  "/network/diddocs/{did}": {
    /** Gets a DID document by its DID */
    get: operations["getNetworkDIDDocByDID"];
  };
  "/network/identities": {
    /** Gets the list of identities in the network (deprecated - use /identities instead of /network/identities */
    get: operations["getNetworkIdentities"];
  };
  "/network/identities/{did}": {
    /** Gets an identity by its DID */
    get: operations["getNetworkIdentityByDID"];
  };
  "/network/nodes": {
    /** Gets a list of nodes in the network */
    get: operations["getNetworkNodes"];
  };
  "/network/nodes/{nameOrId}": {
    /** Gets information about a specific node in the network */
    get: operations["getNetworkNode"];
  };
  "/network/nodes/self": {
    /** Instructs this FireFly node to register itself on the network */
    post: operations["postNodesSelf"];
  };
  "/network/organizations": {
    /** Gets a list of orgs in the network */
    get: operations["getNetworkOrgs"];
    /** Registers a new org in the network */
    post: operations["postNewOrganization"];
  };
  "/network/organizations/{nameOrId}": {
    /** Gets information about a specific org in the network */
    get: operations["getNetworkOrg"];
  };
  "/network/organizations/self": {
    /** Instructs this FireFly node to register its org on the network */
    post: operations["postNewOrganizationSelf"];
  };
  "/nextpins": {
    /** Queries the list of next-pins that determine the next masked message sequence for each member of a privacy group, on each context/topic */
    get: operations["getNextPins"];
  };
  "/operations": {
    /** Gets a a list of operations */
    get: operations["getOps"];
  };
  "/operations/{opid}": {
    /** Gets an operation by ID */
    get: operations["getOpByID"];
  };
  "/operations/{opid}/retry": {
    /** Retries a failed operation */
    post: operations["postOpRetry"];
  };
  "/pins": {
    /** Queries the list of pins received from the blockchain */
    get: operations["getPins"];
  };
  "/pins/rewind": {
    /** Force a rewind of the event aggregator to a previous position, to re-evaluate (and possibly dispatch) that pin and others after it. Only accepts a sequence or batch ID for a currently undispatched pin */
    post: operations["postPinsRewind"];
  };
  "/status": {
    /** Gets the status of this namespace */
    get: operations["getStatus"];
  };
  "/status/batchmanager": {
    /** Gets the status of the batch manager */
    get: operations["getStatusBatchManager"];
  };
  "/subscriptions": {
    /** Gets a list of subscriptions */
    get: operations["getSubscriptions"];
    /** Update an existing subscription */
    put: operations["putSubscription"];
    /** Creates a new subscription for an application to receive events from FireFly */
    post: operations["postNewSubscription"];
  };
  "/subscriptions/{subid}": {
    /** Gets a subscription by its ID */
    get: operations["getSubscriptionByID"];
    /** Deletes a subscription */
    delete: operations["deleteSubscription"];
  };
  "/tokens/accounts": {
    /** Gets a list of token accounts */
    get: operations["getTokenAccounts"];
  };
  "/tokens/accounts/{key}/pools": {
    /** Gets a list of token pools that contain a given token account key */
    get: operations["getTokenAccountPools"];
  };
  "/tokens/approvals": {
    /** Gets a list of token approvals */
    get: operations["getTokenApprovals"];
    /** Creates a token approval */
    post: operations["postTokenApproval"];
  };
  "/tokens/balances": {
    /** Gets a list of token balances */
    get: operations["getTokenBalances"];
  };
  "/tokens/burn": {
    /** Burns some tokens */
    post: operations["postTokenBurn"];
  };
  "/tokens/connectors": {
    /** Gets the list of token connectors currently in use */
    get: operations["getTokenConnectors"];
  };
  "/tokens/mint": {
    /** Mints some tokens */
    post: operations["postTokenMint"];
  };
  "/tokens/pools": {
    /** Gets a list of token pools */
    get: operations["getTokenPools"];
    /** Creates a new token pool */
    post: operations["postTokenPool"];
  };
  "/tokens/pools/{nameOrId}": {
    /** Gets a token pool by its name or its ID */
    get: operations["getTokenPoolByNameOrID"];
    /** Delete a token pool */
    delete: operations["deleteTokenPool"];
  };
  "/tokens/pools/{nameOrId}/publish": {
    /** Publish a token pool to all other members of the multiparty network */
    post: operations["postTokenPoolPublish"];
  };
  "/tokens/transfers": {
    /** Gets a list of token transfers */
    get: operations["getTokenTransfers"];
    /** Transfers some tokens */
    post: operations["postTokenTransfer"];
  };
  "/tokens/transfers/{transferId}": {
    /** Gets a token transfer by its ID */
    get: operations["getTokenTransferByID"];
  };
  "/transactions": {
    /** Gets a list of transactions */
    get: operations["getTxns"];
  };
  "/transactions/{txnid}": {
    /** Gets a transaction by its ID */
    get: operations["getTxnByID"];
  };
  "/transactions/{txnid}/blockchainevents": {
    /** Gets a list blockchain events for a specific transaction */
    get: operations["getTxnBlockchainEvents"];
  };
  "/transactions/{txnid}/operations": {
    /** Gets a list of operations in a specific transaction */
    get: operations["getTxnOps"];
  };
  "/transactions/{txnid}/status": {
    /** Gets the status of a transaction */
    get: operations["getTxnStatus"];
  };
  "/verifiers": {
    /** Gets a list of verifiers */
    get: operations["getVerifiers"];
  };
  "/verifiers/{hash}": {
    /** Gets a verifier by its hash */
    get: operations["getVerifierByID"];
  };
  "/verifiers/resolve": {
    /** Resolves an input key to a signing key */
    post: operations["postVerifiersResolve"];
  };
  "/websockets": {
    /** Gets a list of the current WebSocket connections to this node */
    get: operations["getWebSockets"];
  };
}

export interface components {}

export interface operations {
  /** Gets a list of contract APIs that have been published */
  getContractAPIs: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        networkname?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        published?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates and broadcasts a new custom smart contract API */
  postNewContractAPI: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
        /** When true the definition will be published to all other members of the multiparty network */
        publish?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Reference to the FireFly Interface definition associated with the contract API */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description The name that is used in the URL to access the API */
          name?: string;
          /** @description The published name of the API within the multiparty network */
          networkName?: string;
        };
      };
    };
  };
  /** Gets information about a contract API, including the URLs for the OpenAPI Spec and Swagger UI for the API */
  getContractAPIByName: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      default: unknown;
    };
  };
  /** Delete a contract API */
  deleteContractAPI: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Gets a contract interface for a contract API */
  getContractAPIInterface: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Invokes a method on a smart contract API. Performs a blockchain transaction. */
  postContractAPIInvoke: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a method on a smart contract */
        methodPath: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of contract listeners */
  getContractAPIListeners: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a event on a smart contract */
        eventPath: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        backendid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        location?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        signature?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new blockchain listener for events emitted by custom smart contracts */
  postContractAPIListeners: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a event on a smart contract */
        eventPath: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description A descriptive name for the listener */
          name?: string;
          /** @description Options that control how the listener subscribes to events from the underlying blockchain */
          options?: {
            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
            firstEvent?: string;
          };
          /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
          topic?: string;
        };
      };
    };
  };
  /** Publish a contract API to all other members of the multiparty network */
  postContractAPIPublish: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
          networkName?: string;
        };
      };
    };
  };
  /** Queries a method on a smart contract API. Performs a read-only query. */
  postContractAPIQuery: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a method on a smart contract */
        methodPath: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": { [key: string]: unknown };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** The ID of the contract API */
  putContractAPI: {
    parameters: {
      path: {
        /** The name of the contract API */
        id: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Reference to the FireFly Interface definition associated with the contract API */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description The name that is used in the URL to access the API */
          name?: string;
          /** @description The published name of the API within the multiparty network */
          networkName?: string;
        };
      };
    };
  };
  /** Gets a list of message batches */
  getBatches: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        node?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        payloadref?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: date-time
             * @description The time when the batch was confirmed
             */
            confirmed?: string;
            /**
             * Format: date-time
             * @description The time the batch was sealed
             */
            created?: string;
            /**
             * Format: byte
             * @description The privacy group the batch is sent to, for private batches
             */
            group?: string;
            /**
             * Format: byte
             * @description The hash of the manifest of the batch
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the batch
             */
            id?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The manifest of the batch */
            manifest?: any;
            /** @description The namespace of the batch */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the node that generated the batch
             */
            node?: string;
            /** @description The FireFly transaction associated with this batch */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of the batch
             * @enum {string}
             */
            type?: "broadcast" | "private";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a message batch */
  getBatchByID: {
    parameters: {
      path: {
        /** The batch ID */
        batchid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: date-time
             * @description The time when the batch was confirmed
             */
            confirmed?: string;
            /**
             * Format: date-time
             * @description The time the batch was sealed
             */
            created?: string;
            /**
             * Format: byte
             * @description The privacy group the batch is sent to, for private batches
             */
            group?: string;
            /**
             * Format: byte
             * @description The hash of the manifest of the batch
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the batch
             */
            id?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The manifest of the batch */
            manifest?: any;
            /** @description The namespace of the batch */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the node that generated the batch
             */
            node?: string;
            /** @description The FireFly transaction associated with this batch */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of the batch
             * @enum {string}
             */
            type?: "broadcast" | "private";
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of blockchain events */
  getBlockchainEvents: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        listener?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        protocolid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        source?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        timestamp?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.blockchainid"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID assigned to the event by FireFly
             */
            id?: string;
            /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
            info?: { [key: string]: any };
            /**
             * Format: uuid
             * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
             */
            listener?: string;
            /** @description The name of the event in the blockchain smart contract */
            name?: string;
            /** @description The namespace of the listener that detected this blockchain event */
            namespace?: string;
            /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
            output?: { [key: string]: any };
            /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
            protocolId?: string;
            /** @description The blockchain plugin or token service that detected the event */
            source?: string;
            /**
             * Format: date-time
             * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
             */
            timestamp?: string;
            /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
            tx?: {
              /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
              blockchainId?: string;
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a blockchain event */
  getBlockchainEventByID: {
    parameters: {
      path: {
        /** The blockchain event ID */
        id: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID assigned to the event by FireFly
             */
            id?: string;
            /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
            info?: { [key: string]: any };
            /**
             * Format: uuid
             * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
             */
            listener?: string;
            /** @description The name of the event in the blockchain smart contract */
            name?: string;
            /** @description The namespace of the listener that detected this blockchain event */
            namespace?: string;
            /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
            output?: { [key: string]: any };
            /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
            protocolId?: string;
            /** @description The blockchain plugin or token service that detected the event */
            source?: string;
            /**
             * Format: date-time
             * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
             */
            timestamp?: string;
            /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
            tx?: {
              /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
              blockchainId?: string;
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a JSON object containing statistics data that can be used to build a graphical representation of recent activity in a given database collection */
  getChartHistogram: {
    parameters: {
      path: {
        /** The collection ID */
        collection: string;
      };
      query: {
        /** Start time of the data to be fetched */
        startTime?: string;
        /** End time of the data to be fetched */
        endTime?: string;
        /** Number of buckets between start time and end time */
        buckets?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Total count of entries in this time bucket within the histogram */
            count?: string;
            /** @description Indicates whether there are more results in this bucket that are not being displayed */
            isCapped?: boolean;
            /**
             * Format: date-time
             * @description Starting timestamp for the bucket
             */
            timestamp?: string;
            /** @description Array of separate counts for individual types of record within the bucket */
            types?: {
              /** @description Count of entries of a given type within a bucket */
              count?: string;
              /** @description Name of the type */
              type?: string;
            }[];
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Deploy a new smart contract */
  postContractDeploy: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The smart contract to deploy. This should be pre-compiled if required by the blockchain connector */
          contract?: any;
          /** @description The definition of the smart contract */
          definition?: any;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description An optional array of inputs passed to the smart contract's constructor, if applicable */
          input?: any[];
          /** @description The blockchain signing key that will be used to deploy the contract. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of contract interfaces that have been published */
  getContractInterfaces: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        networkname?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        published?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        version?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates and broadcasts a new custom smart contract interface */
  postNewContractInterface: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
        /** When true the definition will be published to all other members of the multiparty network */
        publish?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the smart contract this FFI represents */
          description?: string;
          /** @description An array of smart contract error definitions */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An array of smart contract event definitions */
          events?: {
            /** @description A description of the smart contract event */
            description?: string;
            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the event */
            name?: string;
            /** @description An array of event parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An array of smart contract method definitions */
          methods?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description The name of the FFI - usually matching the smart contract name */
          name?: string;
          /** @description The published name of the FFI within the multiparty network */
          networkName?: string;
          /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
          version?: string;
        };
      };
    };
  };
  /** Gets a contract interface by its ID */
  getContractInterface: {
    parameters: {
      path: {
        /** The ID of the contract interface */
        interfaceId: string;
      };
      query: {
        /** When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
        fetchchildren?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Delete a contract interface */
  deleteContractInterface: {
    parameters: {
      path: {
        /** The ID of the contract interface */
        interfaceId: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Gets a contract interface by its name and version */
  getContractInterfaceByNameAndVersion: {
    parameters: {
      path: {
        /** The name of the contract interface */
        name: string;
        /** The version of the contract interface */
        version: string;
      };
      query: {
        /** When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
        fetchchildren?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Publish a contract interface to all other members of the multiparty network */
  postContractInterfacePublish: {
    parameters: {
      path: {
        /** The name of the contract interface */
        name: string;
        /** The version of the contract interface */
        version: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
          networkName?: string;
        };
      };
    };
  };
  /** A convenience method to convert a blockchain specific smart contract format into a FireFly Interface format. The specific blockchain plugin in use must support this functionality. */
  postGenerateContractInterface: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The description of the FFI to be generated. Defaults to the description extracted by the blockchain specific converter utility */
          description?: string;
          /** @description A blockchain connector specific payload. For example in Ethereum this is a JSON structure containing an 'abi' array, and optionally a 'devdocs' array. */
          input?: any;
          /** @description The name of the FFI to generate */
          name?: string;
          /** @description The namespace into which the FFI will be generated */
          namespace?: string;
          /** @description The version of the FFI to generate */
          version?: string;
        };
      };
    };
  };
  /** Invokes a method on a smart contract. Performs a blockchain transaction. */
  postContractInvoke: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /**
           * Format: uuid
           * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
           */
          interface?: string;
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
          method?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description The pathname of the method on the specified FFI */
          methodPath?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of contract listeners */
  getContractListeners: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        backendid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        location?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        signature?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new blockchain listener for events emitted by custom smart contracts */
  postNewContractListener: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
          event?: {
            /** @description A description of the smart contract event */
            description?: string;
            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the event */
            name?: string;
            /** @description An array of event parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description When creating a listener from an existing FFI, this is the pathname of the event on that FFI to be detected by this listener */
          eventPath?: string;
          /** @description A reference to an existing FFI, containing pre-registered type information for the event */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description A descriptive name for the listener */
          name?: string;
          /** @description Options that control how the listener subscribes to events from the underlying blockchain */
          options?: {
            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
            firstEvent?: string;
          };
          /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
          topic?: string;
        };
      };
    };
  };
  /** Gets a contract listener by its name or ID */
  getContractListenerByNameOrID: {
    parameters: {
      path: {
        /** The contract listener name or ID */
        nameOrId: string;
      };
      query: {
        /** When set, the API will return additional status information if available */
        fetchstatus?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Deletes a contract listener referenced by its name or its ID */
  deleteContractListener: {
    parameters: {
      path: {
        /** The contract listener name or ID */
        nameOrId: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Queries a method on a smart contract. Performs a read-only query. */
  postContractQuery: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": { [key: string]: unknown };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /**
           * Format: uuid
           * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
           */
          interface?: string;
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
          method?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description The pathname of the method on the specified FFI */
          methodPath?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of data items */
  getData: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.hash"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.name"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.path"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.public"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.size"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "datatype.name"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "datatype.version"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        public?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        validator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        value?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new data item in this FireFly node */
  postData: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The optional datatype to use for validation of the in-line data */
          datatype?: {
            /** @description The name of the datatype */
            name?: string;
            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
            version?: string;
          };
          /**
           * Format: uuid
           * @description The UUID of the referenced data resource
           */
          id?: string;
          /** @description The data validator type to use for in-line data */
          validator?: string;
          /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
          value?: any;
        };
        "multipart/form-data": {
          /** @description Success */
          autometa?: string;
          /** @description Success */
          "datatype.name"?: string;
          /** @description Success */
          "datatype.version"?: string;
          /** Format: binary */
          "filename.ext"?: string;
          /** @description Success */
          metadata?: string;
          /** @description Success */
          validator?: string;
        };
      };
    };
  };
  /** Gets a data item by its ID, including metadata about this item */
  getDataByID: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
  };
  /** Deletes a data item by its ID, including metadata about this item */
  deleteData: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Downloads the original file that was previously uploaded or received */
  getDataBlob: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": string;
        };
      };
      default: unknown;
    };
  };
  /** Publishes the binary blob attachment stored in your local data exchange, to shared storage */
  postDataBlobPublish: {
    parameters: {
      path: {
        /** The blob ID */
        dataid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Gets a list of the messages associated with a data item */
  getDataMsgs: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Downloads the JSON value of the data resource, without the associated metadata */
  getDataValue: {
    parameters: {
      path: {
        /** The blob ID */
        dataid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": string;
        };
      };
      default: unknown;
    };
  };
  /** Publishes the JSON value from the specified data resource, to shared storage */
  postDataValuePublish: {
    parameters: {
      path: {
        /** The blob ID */
        dataid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Gets a list of path names of named blob data, underneath a given parent path ('/' path prefixes are automatically pre-prepended) */
  getDataSubPaths: {
    parameters: {
      path: {
        /** The parent path to query */
        parent: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": string[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of datatypes that have been published */
  getDatatypes: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        validator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        version?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates and broadcasts a new datatype */
  postNewDatatype: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The name of the datatype */
          name?: string;
          /**
           * @description The validator that should be used to verify this datatype
           * @enum {string}
           */
          validator?: "json" | "none" | "definition";
          /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
          value?: any;
          /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
          version?: string;
        };
      };
    };
  };
  /** Gets a datatype by its name and version */
  getDatatypeByName: {
    parameters: {
      path: {
        /** The name of the datatype */
        name: string;
        /** The version of the datatype */
        version: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of events */
  getEvents: {
    parameters: {
      query: {
        /** When set, the API will return the record that this item references in its 'reference' field */
        fetchreferences?: string;
        /** When set, the API will return the record that this item references in its 'reference' field */
        fetchreference?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        correlator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        reference?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tx?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
             */
            correlator?: string;
            /**
             * Format: date-time
             * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID assigned to this event by your local FireFly node
             */
            id?: string;
            /** @description The namespace of the event. Your application must subscribe to events within a namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
             */
            reference?: string;
            /**
             * Format: int64
             * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
             */
            sequence?: number;
            /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
            topic?: string;
            /**
             * Format: uuid
             * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
             */
            tx?: string;
            /**
             * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
             * @enum {string}
             */
            type?:
              | "transaction_submitted"
              | "message_confirmed"
              | "message_rejected"
              | "datatype_confirmed"
              | "identity_confirmed"
              | "identity_updated"
              | "token_pool_confirmed"
              | "token_pool_op_failed"
              | "token_transfer_confirmed"
              | "token_transfer_op_failed"
              | "token_approval_confirmed"
              | "token_approval_op_failed"
              | "contract_interface_confirmed"
              | "contract_api_confirmed"
              | "blockchain_event_received"
              | "blockchain_invoke_op_succeeded"
              | "blockchain_invoke_op_failed"
              | "blockchain_contract_deploy_op_succeeded"
              | "blockchain_contract_deploy_op_failed";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets an event by its ID */
  getEventByID: {
    parameters: {
      path: {
        /** The event ID */
        eid: string;
      };
      query: {
        /** When set, the API will return the record that this item references in its 'reference' field */
        fetchreference?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
             */
            correlator?: string;
            /**
             * Format: date-time
             * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID assigned to this event by your local FireFly node
             */
            id?: string;
            /** @description The namespace of the event. Your application must subscribe to events within a namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
             */
            reference?: string;
            /**
             * Format: int64
             * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
             */
            sequence?: number;
            /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
            topic?: string;
            /**
             * Format: uuid
             * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
             */
            tx?: string;
            /**
             * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
             * @enum {string}
             */
            type?:
              | "transaction_submitted"
              | "message_confirmed"
              | "message_rejected"
              | "datatype_confirmed"
              | "identity_confirmed"
              | "identity_updated"
              | "token_pool_confirmed"
              | "token_pool_op_failed"
              | "token_transfer_confirmed"
              | "token_transfer_op_failed"
              | "token_approval_confirmed"
              | "token_approval_op_failed"
              | "contract_interface_confirmed"
              | "contract_api_confirmed"
              | "blockchain_event_received"
              | "blockchain_invoke_op_succeeded"
              | "blockchain_invoke_op_failed"
              | "blockchain_contract_deploy_op_succeeded"
              | "blockchain_contract_deploy_op_failed";
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of groups */
  getGroups: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        ledger?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time when the group was first used to send a message in the network
             */
            created?: string;
            /**
             * Format: byte
             * @description The identifier hash of this group. Derived from the name and group members
             */
            hash?: string;
            /** @description The local namespace of the group */
            localNamespace?: string;
            /** @description The list of members in this privacy group */
            members?: {
              /** @description The DID of the group member */
              identity?: string;
              /**
               * Format: uuid
               * @description The UUID of the node that receives a copy of the off-chain message for the identity
               */
              node?: string;
            }[];
            /**
             * Format: uuid
             * @description The message used to broadcast this group privately to the members
             */
            message?: string;
            /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
            name?: string;
            /** @description The namespace of the group within the multiparty network */
            namespace?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a group by its ID (hash) */
  getGroupByHash: {
    parameters: {
      path: {
        /** The hash of the group */
        hash: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time when the group was first used to send a message in the network
             */
            created?: string;
            /**
             * Format: byte
             * @description The identifier hash of this group. Derived from the name and group members
             */
            hash?: string;
            /** @description The local namespace of the group */
            localNamespace?: string;
            /** @description The list of members in this privacy group */
            members?: {
              /** @description The DID of the group member */
              identity?: string;
              /**
               * Format: uuid
               * @description The UUID of the node that receives a copy of the off-chain message for the identity
               */
              node?: string;
            }[];
            /**
             * Format: uuid
             * @description The message used to broadcast this group privately to the members
             */
            message?: string;
            /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
            name?: string;
            /** @description The namespace of the group within the multiparty network */
            namespace?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of all identities that have been registered in the namespace */
  getIdentities: {
    parameters: {
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Registers a new identity in the network */
  postNewIdentity: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the identity. Part of the updatable profile information of an identity */
          description?: string;
          /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
          key?: string;
          /** @description The name of the identity. The name must be unique within the type and namespace */
          name?: string;
          /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
          parent?: string;
          /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
          profile?: { [key: string]: any };
          /** @description The type of the identity */
          type?: string;
        };
      };
    };
  };
  /** Gets an identity by its DID */
  getIdentityByDID: {
    parameters: {
      path: {
        /** The identity DID */
        did: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets an identity by its ID */
  getIdentityByID: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Updates an identity */
  patchUpdateIdentity: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the identity. Part of the updatable profile information of an identity */
          description?: string;
          /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
          profile?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets the DID for an identity based on its ID */
  getIdentityDID: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description See https://www.w3.org/TR/did-core/#json-ld */
            "@context"?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            authentication?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            id?: string;
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            verificationMethod?: {
              /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
              blockchainAcountId?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              controller?: string;
              /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
              dataExchangePeerID?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              id?: string;
              /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
              mspIdentityString?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              type?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the verifiers for an identity */
  getIdentityVerifiers: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        identity?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        value?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time this verifier was created on this node
             */
            created?: string;
            /**
             * Format: byte
             * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity that has claimed this verifier
             */
            identity?: string;
            /** @description The namespace of the verifier */
            namespace?: string;
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of messages */
  getMsgs: {
    parameters: {
      query: {
        /** Fetch the data and include it in the messages returned */
        fetchdata?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a message by its ID */
  getMsgByID: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
      };
      query: {
        /** Fetch the data and include it in the messages returned */
        fetchdata?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description An optional in-line hash reference to a previously uploaded binary data blob */
              blob?: {
                /**
                 * Format: byte
                 * @description The hash of the binary blob data
                 */
                hash?: string;
                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                name?: string;
                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                path?: string;
                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                public?: string;
                /**
                 * Format: int64
                 * @description The size of the binary data
                 */
                size?: number;
              };
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the list of data items that are attached to a message */
  getMsgData: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets the list of events for a message */
  getMsgEvents: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        correlator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        reference?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tx?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
             */
            correlator?: string;
            /**
             * Format: date-time
             * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID assigned to this event by your local FireFly node
             */
            id?: string;
            /** @description The namespace of the event. Your application must subscribe to events within a namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
             */
            reference?: string;
            /**
             * Format: int64
             * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
             */
            sequence?: number;
            /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
            topic?: string;
            /**
             * Format: uuid
             * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
             */
            tx?: string;
            /**
             * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
             * @enum {string}
             */
            type?:
              | "transaction_submitted"
              | "message_confirmed"
              | "message_rejected"
              | "datatype_confirmed"
              | "identity_confirmed"
              | "identity_updated"
              | "token_pool_confirmed"
              | "token_pool_op_failed"
              | "token_transfer_confirmed"
              | "token_transfer_op_failed"
              | "token_approval_confirmed"
              | "token_approval_op_failed"
              | "contract_interface_confirmed"
              | "contract_api_confirmed"
              | "blockchain_event_received"
              | "blockchain_invoke_op_succeeded"
              | "blockchain_invoke_op_failed"
              | "blockchain_contract_deploy_op_succeeded"
              | "blockchain_contract_deploy_op_failed";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets the transaction for a message */
  getMsgTxn: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
            blockchainIds?: string[];
            /**
             * Format: date-time
             * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction
             */
            id?: string;
            /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
            idempotencyKey?: string;
            /** @description The namespace of the FireFly transaction */
            namespace?: string;
            /**
             * @description The type of the FireFly transaction
             * @enum {string}
             */
            type?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
          };
        };
      };
      default: unknown;
    };
  };
  /** Broadcasts a message to all members in the network */
  postNewMessageBroadcast: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
          data?: {
            /** @description The optional datatype to use for validation of the in-line data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: uuid
             * @description The UUID of the referenced data resource
             */
            id?: string;
            /** @description The data validator type to use for in-line data */
            validator?: string;
            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
            value?: any;
          }[];
          /** @description The message header contains all fields that are used to build the message hash */
          header?: {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: uuid
             * @description The correlation ID of the message. Set this when a message is a response to another message
             */
            cid?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The message tag indicates the purpose of the message to the applications that process it */
            tag?: string;
            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
            topics?: string[];
            /**
             * @description The type of transaction used to order/deliver this message
             * @enum {string}
             */
            txtype?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
            /**
             * @description The type of the message
             * @enum {string}
             */
            type?:
              | "definition"
              | "broadcast"
              | "private"
              | "groupinit"
              | "transfer_broadcast"
              | "transfer_private"
              | "approval_broadcast"
              | "approval_private";
          };
          /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Privately sends a message to one or more members in the network */
  postNewMessagePrivate: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
          data?: {
            /** @description The optional datatype to use for validation of the in-line data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: uuid
             * @description The UUID of the referenced data resource
             */
            id?: string;
            /** @description The data validator type to use for in-line data */
            validator?: string;
            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
            value?: any;
          }[];
          /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
          group?: {
            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
            members?: {
              /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
              identity?: string;
              /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
              node?: string;
            }[];
            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
            name?: string;
          };
          /** @description The message header contains all fields that are used to build the message hash */
          header?: {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: uuid
             * @description The correlation ID of the message. Set this when a message is a response to another message
             */
            cid?: string;
            /**
             * Format: byte
             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
             */
            group?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The message tag indicates the purpose of the message to the applications that process it */
            tag?: string;
            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
            topics?: string[];
            /**
             * @description The type of transaction used to order/deliver this message
             * @enum {string}
             */
            txtype?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
            /**
             * @description The type of the message
             * @enum {string}
             */
            type?:
              | "definition"
              | "broadcast"
              | "private"
              | "groupinit"
              | "transfer_broadcast"
              | "transfer_private"
              | "approval_broadcast"
              | "approval_private";
          };
          /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Sends a message with a blocking HTTP request, waits for a reply to that message, then sends the reply as the HTTP response. */
  postNewMessageRequestReply: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description An optional in-line hash reference to a previously uploaded binary data blob */
              blob?: {
                /**
                 * Format: byte
                 * @description The hash of the binary blob data
                 */
                hash?: string;
                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                name?: string;
                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                path?: string;
                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                public?: string;
                /**
                 * Format: int64
                 * @description The size of the binary data
                 */
                size?: number;
              };
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
          data?: {
            /** @description The optional datatype to use for validation of the in-line data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: uuid
             * @description The UUID of the referenced data resource
             */
            id?: string;
            /** @description The data validator type to use for in-line data */
            validator?: string;
            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
            value?: any;
          }[];
          /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
          group?: {
            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
            members?: {
              /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
              identity?: string;
              /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
              node?: string;
            }[];
            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
            name?: string;
          };
          /** @description The message header contains all fields that are used to build the message hash */
          header?: {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: uuid
             * @description The correlation ID of the message. Set this when a message is a response to another message
             */
            cid?: string;
            /**
             * Format: byte
             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
             */
            group?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The message tag indicates the purpose of the message to the applications that process it */
            tag?: string;
            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
            topics?: string[];
            /**
             * @description The type of transaction used to order/deliver this message
             * @enum {string}
             */
            txtype?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
            /**
             * @description The type of the message
             * @enum {string}
             */
            type?:
              | "definition"
              | "broadcast"
              | "private"
              | "groupinit"
              | "transfer_broadcast"
              | "transfer_private"
              | "approval_broadcast"
              | "approval_private";
          };
          /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Gets a list of namespaces */
  getNamespaces: {
    parameters: {
      query: {
        /** When set, the API will return namespaces even if they are not yet initialized, including in error cases where an initializationError is included */
        includeinitializing?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the namespace was created
             */
            created?: string;
            /** @description A description of the namespace */
            description?: string;
            /** @description Set to a non-empty string in the case that the namespace is currently failing to initialize */
            initializationError?: string;
            /** @description Set to true if the namespace is still initializing */
            initializing?: boolean;
            /** @description The local namespace name */
            name?: string;
            /** @description The shared namespace name within the multiparty network */
            networkName?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a namespace */
  getNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the namespace was created
             */
            created?: string;
            /** @description A description of the namespace */
            description?: string;
            /** @description The local namespace name */
            name?: string;
            /** @description The shared namespace name within the multiparty network */
            networkName?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of contract APIs that have been published */
  getContractAPIsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        networkname?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        published?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates and broadcasts a new custom smart contract API */
  postNewContractAPINamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
        /** When true the definition will be published to all other members of the multiparty network */
        publish?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Reference to the FireFly Interface definition associated with the contract API */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description The name that is used in the URL to access the API */
          name?: string;
          /** @description The published name of the API within the multiparty network */
          networkName?: string;
        };
      };
    };
  };
  /** Gets information about a contract API, including the URLs for the OpenAPI Spec and Swagger UI for the API */
  getContractAPIByNameNamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      default: unknown;
    };
  };
  /** Delete a contract API */
  deleteContractAPINamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Gets a contract interface for a contract API */
  getContractAPIInterfaceNamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Invokes a method on a smart contract API. Performs a blockchain transaction. */
  postContractAPIInvokeNamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a method on a smart contract */
        methodPath: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /**
           * Format: uuid
           * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
           */
          interface?: string;
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
          method?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description The pathname of the method on the specified FFI */
          methodPath?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of contract listeners */
  getContractAPIListenersNamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a event on a smart contract */
        eventPath: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        backendid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        location?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        signature?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new blockchain listener for events emitted by custom smart contracts */
  postContractAPIListenersNamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a event on a smart contract */
        eventPath: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
          event?: {
            /** @description A description of the smart contract event */
            description?: string;
            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the event */
            name?: string;
            /** @description An array of event parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description A reference to an existing FFI, containing pre-registered type information for the event */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description A descriptive name for the listener */
          name?: string;
          /** @description Options that control how the listener subscribes to events from the underlying blockchain */
          options?: {
            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
            firstEvent?: string;
          };
          /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
          topic?: string;
        };
      };
    };
  };
  /** Publish a contract API to all other members of the multiparty network */
  postContractAPIPublishNamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
          networkName?: string;
        };
      };
    };
  };
  /** Queries a method on a smart contract API. Performs a read-only query. */
  postContractAPIQueryNamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        apiName: string;
        /** The name or uniquely generated path name of a method on a smart contract */
        methodPath: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": { [key: string]: unknown };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /**
           * Format: uuid
           * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
           */
          interface?: string;
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
          method?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description The pathname of the method on the specified FFI */
          methodPath?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** The ID of the contract API */
  putContractAPINamespace: {
    parameters: {
      path: {
        /** The name of the contract API */
        id: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the contract API
             */
            id?: string;
            /** @description Reference to the FireFly Interface definition associated with the contract API */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this API to the network
             */
            message?: string;
            /** @description The name that is used in the URL to access the API */
            name?: string;
            /** @description The namespace of the contract API */
            namespace?: string;
            /** @description The published name of the API within the multiparty network */
            networkName?: string;
            /** @description Indicates if the API is published to other members of the multiparty network */
            published?: boolean;
            /** @description The URLs to use to access the API */
            urls?: {
              /** @description The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format */
              openapi?: string;
              /** @description The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API */
              ui?: string;
            };
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Reference to the FireFly Interface definition associated with the contract API */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description The name that is used in the URL to access the API */
          name?: string;
          /** @description The published name of the API within the multiparty network */
          networkName?: string;
        };
      };
    };
  };
  /** Gets a list of message batches */
  getBatchesNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        node?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        payloadref?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: date-time
             * @description The time when the batch was confirmed
             */
            confirmed?: string;
            /**
             * Format: date-time
             * @description The time the batch was sealed
             */
            created?: string;
            /**
             * Format: byte
             * @description The privacy group the batch is sent to, for private batches
             */
            group?: string;
            /**
             * Format: byte
             * @description The hash of the manifest of the batch
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the batch
             */
            id?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The manifest of the batch */
            manifest?: any;
            /** @description The namespace of the batch */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the node that generated the batch
             */
            node?: string;
            /** @description The FireFly transaction associated with this batch */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of the batch
             * @enum {string}
             */
            type?: "broadcast" | "private";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a message batch */
  getBatchByIDNamespace: {
    parameters: {
      path: {
        /** The batch ID */
        batchid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: date-time
             * @description The time when the batch was confirmed
             */
            confirmed?: string;
            /**
             * Format: date-time
             * @description The time the batch was sealed
             */
            created?: string;
            /**
             * Format: byte
             * @description The privacy group the batch is sent to, for private batches
             */
            group?: string;
            /**
             * Format: byte
             * @description The hash of the manifest of the batch
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the batch
             */
            id?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The manifest of the batch */
            manifest?: any;
            /** @description The namespace of the batch */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the node that generated the batch
             */
            node?: string;
            /** @description The FireFly transaction associated with this batch */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of the batch
             * @enum {string}
             */
            type?: "broadcast" | "private";
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of blockchain events */
  getBlockchainEventsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        listener?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        protocolid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        source?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        timestamp?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.blockchainid"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID assigned to the event by FireFly
             */
            id?: string;
            /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
            info?: { [key: string]: any };
            /**
             * Format: uuid
             * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
             */
            listener?: string;
            /** @description The name of the event in the blockchain smart contract */
            name?: string;
            /** @description The namespace of the listener that detected this blockchain event */
            namespace?: string;
            /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
            output?: { [key: string]: any };
            /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
            protocolId?: string;
            /** @description The blockchain plugin or token service that detected the event */
            source?: string;
            /**
             * Format: date-time
             * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
             */
            timestamp?: string;
            /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
            tx?: {
              /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
              blockchainId?: string;
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a blockchain event */
  getBlockchainEventByIDNamespace: {
    parameters: {
      path: {
        /** The blockchain event ID */
        id: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID assigned to the event by FireFly
             */
            id?: string;
            /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
            info?: { [key: string]: any };
            /**
             * Format: uuid
             * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
             */
            listener?: string;
            /** @description The name of the event in the blockchain smart contract */
            name?: string;
            /** @description The namespace of the listener that detected this blockchain event */
            namespace?: string;
            /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
            output?: { [key: string]: any };
            /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
            protocolId?: string;
            /** @description The blockchain plugin or token service that detected the event */
            source?: string;
            /**
             * Format: date-time
             * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
             */
            timestamp?: string;
            /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
            tx?: {
              /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
              blockchainId?: string;
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a JSON object containing statistics data that can be used to build a graphical representation of recent activity in a given database collection */
  getChartHistogramNamespace: {
    parameters: {
      path: {
        /** The collection ID */
        collection: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** Start time of the data to be fetched */
        startTime?: string;
        /** End time of the data to be fetched */
        endTime?: string;
        /** Number of buckets between start time and end time */
        buckets?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Total count of entries in this time bucket within the histogram */
            count?: string;
            /** @description Indicates whether there are more results in this bucket that are not being displayed */
            isCapped?: boolean;
            /**
             * Format: date-time
             * @description Starting timestamp for the bucket
             */
            timestamp?: string;
            /** @description Array of separate counts for individual types of record within the bucket */
            types?: {
              /** @description Count of entries of a given type within a bucket */
              count?: string;
              /** @description Name of the type */
              type?: string;
            }[];
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Deploy a new smart contract */
  postContractDeployNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The smart contract to deploy. This should be pre-compiled if required by the blockchain connector */
          contract?: any;
          /** @description The definition of the smart contract */
          definition?: any;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description An optional array of inputs passed to the smart contract's constructor, if applicable */
          input?: any[];
          /** @description The blockchain signing key that will be used to deploy the contract. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of contract interfaces that have been published */
  getContractInterfacesNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        networkname?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        published?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        version?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates and broadcasts a new custom smart contract interface */
  postNewContractInterfaceNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
        /** When true the definition will be published to all other members of the multiparty network */
        publish?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the smart contract this FFI represents */
          description?: string;
          /** @description An array of smart contract error definitions */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An array of smart contract event definitions */
          events?: {
            /** @description A description of the smart contract event */
            description?: string;
            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the event */
            name?: string;
            /** @description An array of event parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An array of smart contract method definitions */
          methods?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description The name of the FFI - usually matching the smart contract name */
          name?: string;
          /** @description The published name of the FFI within the multiparty network */
          networkName?: string;
          /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
          version?: string;
        };
      };
    };
  };
  /** Gets a contract interface by its ID */
  getContractInterfaceNamespace: {
    parameters: {
      path: {
        /** The ID of the contract interface */
        interfaceId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
        fetchchildren?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Delete a contract interface */
  deleteContractInterfaceNamespace: {
    parameters: {
      path: {
        /** The ID of the contract interface */
        interfaceId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Gets a contract interface by its name and version */
  getContractInterfaceByNameAndVersionNamespace: {
    parameters: {
      path: {
        /** The name of the contract interface */
        name: string;
        /** The version of the contract interface */
        version: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the full FireFly Interface document including all methods, events, and parameters */
        fetchchildren?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Publish a contract interface to all other members of the multiparty network */
  postContractInterfacePublishNamespace: {
    parameters: {
      path: {
        /** The name of the contract interface */
        name: string;
        /** The version of the contract interface */
        version: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
          networkName?: string;
        };
      };
    };
  };
  /** A convenience method to convert a blockchain specific smart contract format into a FireFly Interface format. The specific blockchain plugin in use must support this functionality. */
  postGenerateContractInterfaceNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A description of the smart contract this FFI represents */
            description?: string;
            /** @description An array of smart contract error definitions */
            errors?: {
              /** @description A description of the smart contract error */
              description?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI error definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this error is part of
               */
              interface?: string;
              /** @description The name of the error */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of error parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this error within the FFI for use on URL paths */
              pathname?: string;
              /** @description The stringified signature of the error, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /** @description An array of smart contract event definitions */
            events?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI event definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this event is part of
               */
              interface?: string;
              /** @description The name of the event */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name */
              pathname?: string;
              /** @description The stringified signature of the event, as computed by the blockchain plugin */
              signature?: string;
            }[];
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface (FFI) smart contract definition
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this FFI to the network
             */
            message?: string;
            /** @description An array of smart contract method definitions */
            methods?: {
              /** @description A description of the smart contract method */
              description?: string;
              /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /**
               * Format: uuid
               * @description The UUID of the FFI method definition
               */
              id?: string;
              /**
               * Format: uuid
               * @description The UUID of the FFI smart contract definition that this method is part of
               */
              interface?: string;
              /** @description The name of the method */
              name?: string;
              /** @description The namespace of the FFI */
              namespace?: string;
              /** @description An array of method parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
              /** @description The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name */
              pathname?: string;
              /** @description An array of method return definitions */
              returns?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            }[];
            /** @description The name of the FFI - usually matching the smart contract name */
            name?: string;
            /** @description The namespace of the FFI */
            namespace?: string;
            /** @description The published name of the FFI within the multiparty network */
            networkName?: string;
            /** @description Indicates if the FFI is published to other members of the multiparty network */
            published?: boolean;
            /** @description A version for the FFI - use of semantic versioning such as 'v1.0.1' is encouraged */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The description of the FFI to be generated. Defaults to the description extracted by the blockchain specific converter utility */
          description?: string;
          /** @description A blockchain connector specific payload. For example in Ethereum this is a JSON structure containing an 'abi' array, and optionally a 'devdocs' array. */
          input?: any;
          /** @description The name of the FFI to generate */
          name?: string;
          /** @description The namespace into which the FFI will be generated */
          namespace?: string;
          /** @description The version of the FFI to generate */
          version?: string;
        };
      };
    };
  };
  /** Invokes a method on a smart contract. Performs a blockchain transaction. */
  postContractInvokeNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /**
           * Format: uuid
           * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
           */
          interface?: string;
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
          method?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description The pathname of the method on the specified FFI */
          methodPath?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of contract listeners */
  getContractListenersNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        backendid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        location?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        signature?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new blockchain listener for events emitted by custom smart contracts */
  postNewContractListenerNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
          event?: {
            /** @description A description of the smart contract event */
            description?: string;
            /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the event */
            name?: string;
            /** @description An array of event parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description When creating a listener from an existing FFI, this is the pathname of the event on that FFI to be detected by this listener */
          eventPath?: string;
          /** @description A reference to an existing FFI, containing pre-registered type information for the event */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description A descriptive name for the listener */
          name?: string;
          /** @description Options that control how the listener subscribes to events from the underlying blockchain */
          options?: {
            /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
            firstEvent?: string;
          };
          /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
          topic?: string;
        };
      };
    };
  };
  /** Gets a contract listener by its name or ID */
  getContractListenerByNameOrIDNamespace: {
    parameters: {
      path: {
        /** The contract listener name or ID */
        nameOrId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return additional status information if available */
        fetchstatus?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An ID assigned by the blockchain connector to this listener */
            backendId?: string;
            /**
             * Format: date-time
             * @description The creation time of the listener
             */
            created?: string;
            /** @description The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI */
            event?: {
              /** @description A description of the smart contract event */
              description?: string;
              /** @description Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. */
              details?: { [key: string]: any };
              /** @description The name of the event */
              name?: string;
              /** @description An array of event parameter/argument definitions */
              params?: {
                /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
                name?: string;
                /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
                schema?: any;
              }[];
            };
            /**
             * Format: uuid
             * @description The UUID of the smart contract listener
             */
            id?: string;
            /** @description A reference to an existing FFI, containing pre-registered type information for the event */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
            location?: any;
            /** @description A descriptive name for the listener */
            name?: string;
            /** @description The namespace of the listener, which defines the namespace of all blockchain events detected by this listener */
            namespace?: string;
            /** @description Options that control how the listener subscribes to events from the underlying blockchain */
            options?: {
              /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors. Default is 'newest' */
              firstEvent?: string;
            };
            /** @description The stringified signature of the event, as computed by the blockchain plugin */
            signature?: string;
            /** @description A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need */
            topic?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Deletes a contract listener referenced by its name or its ID */
  deleteContractListenerNamespace: {
    parameters: {
      path: {
        /** The contract listener name or ID */
        nameOrId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Queries a method on a smart contract. Performs a read-only query. */
  postContractQueryNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": { [key: string]: unknown };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An in-line FFI errors definition for the method to invoke. Alternative to specifying FFI */
          errors?: {
            /** @description A description of the smart contract error */
            description?: string;
            /** @description The name of the error */
            name?: string;
            /** @description An array of error parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          }[];
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A map of named inputs. The name and type of each input must be compatible with the FFI description of the method, so that FireFly knows how to serialize it to the blockchain via the connector */
          input?: { [key: string]: any };
          /**
           * Format: uuid
           * @description The UUID of a method within a pre-configured FireFly interface (FFI) definition for a smart contract. Required if the 'method' is omitted. Also see Contract APIs as a way to configure a dedicated API for your FFI, including all methods and an OpenAPI/Swagger interface
           */
          interface?: string;
          /** @description The blockchain signing key that will sign the invocation. Defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
          location?: any;
          /** @description You can specify a message to correlate with the invocation, which can be of type broadcast or private. Your specified method must support on-chain/off-chain correlation by taking a data input on the call */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description An in-line FFI method definition for the method to invoke. Required when FFI is not specified */
          method?: {
            /** @description A description of the smart contract method */
            description?: string;
            /** @description Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. */
            details?: { [key: string]: any };
            /** @description The name of the method */
            name?: string;
            /** @description An array of method parameter/argument definitions */
            params?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
            /** @description An array of method return definitions */
            returns?: {
              /** @description The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract */
              name?: string;
              /** @description FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail */
              schema?: any;
            }[];
          };
          /** @description The pathname of the method on the specified FFI */
          methodPath?: string;
          /** @description A map of named inputs that will be passed through to the blockchain connector */
          options?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets a list of data items */
  getDataNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.hash"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.name"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.path"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.public"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "blob.size"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "datatype.name"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "datatype.version"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        public?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        validator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        value?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new data item in this FireFly node */
  postDataNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The optional datatype to use for validation of the in-line data */
          datatype?: {
            /** @description The name of the datatype */
            name?: string;
            /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
            version?: string;
          };
          /**
           * Format: uuid
           * @description The UUID of the referenced data resource
           */
          id?: string;
          /** @description The data validator type to use for in-line data */
          validator?: string;
          /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
          value?: any;
        };
        "multipart/form-data": {
          /** @description Success */
          autometa?: string;
          /** @description Success */
          "datatype.name"?: string;
          /** @description Success */
          "datatype.version"?: string;
          /** Format: binary */
          "filename.ext"?: string;
          /** @description Success */
          metadata?: string;
          /** @description Success */
          validator?: string;
        };
      };
    };
  };
  /** Gets a data item by its ID, including metadata about this item */
  getDataByIDNamespace: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
  };
  /** Deletes a data item by its ID, including metadata about this item */
  deleteDataNamespace: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Downloads the original file that was previously uploaded or received */
  getDataBlobNamespace: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": string;
        };
      };
      default: unknown;
    };
  };
  /** Publishes the binary blob attachment stored in your local data exchange, to shared storage */
  postDataBlobPublishNamespace: {
    parameters: {
      path: {
        /** The blob ID */
        dataid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Gets a list of the messages associated with a data item */
  getDataMsgsNamespace: {
    parameters: {
      path: {
        /** The data item ID */
        dataid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Downloads the JSON value of the data resource, without the associated metadata */
  getDataValueNamespace: {
    parameters: {
      path: {
        /** The blob ID */
        dataid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": string;
        };
      };
      default: unknown;
    };
  };
  /** Publishes the JSON value from the specified data resource, to shared storage */
  postDataValuePublishNamespace: {
    parameters: {
      path: {
        /** The blob ID */
        dataid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Gets a list of path names of named blob data, underneath a given parent path ('/' path prefixes are automatically pre-prepended) */
  getDataSubPathsNamespace: {
    parameters: {
      path: {
        /** The parent path to query */
        parent: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": string[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of datatypes that have been published */
  getDatatypesNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        validator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        version?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates and broadcasts a new datatype */
  postNewDatatypeNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The name of the datatype */
          name?: string;
          /**
           * @description The validator that should be used to verify this datatype
           * @enum {string}
           */
          validator?: "json" | "none" | "definition";
          /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
          value?: any;
          /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
          version?: string;
        };
      };
    };
  };
  /** Gets a datatype by its name and version */
  getDatatypeByNameNamespace: {
    parameters: {
      path: {
        /** The name of the datatype */
        name: string;
        /** The version of the datatype */
        version: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the datatype was created
             */
            created?: string;
            /**
             * Format: byte
             * @description The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the datatype
             */
            id?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message that was used to publish this datatype to the network
             */
            message?: string;
            /** @description The name of the datatype */
            name?: string;
            /** @description The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace */
            namespace?: string;
            /**
             * @description The validator that should be used to verify this datatype
             * @enum {string}
             */
            validator?: "json" | "none" | "definition";
            /** @description The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) */
            value?: any;
            /** @description The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 */
            version?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of events */
  getEventsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the record that this item references in its 'reference' field */
        fetchreferences?: string;
        /** When set, the API will return the record that this item references in its 'reference' field */
        fetchreference?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        correlator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        reference?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tx?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
             */
            correlator?: string;
            /**
             * Format: date-time
             * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID assigned to this event by your local FireFly node
             */
            id?: string;
            /** @description The namespace of the event. Your application must subscribe to events within a namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
             */
            reference?: string;
            /**
             * Format: int64
             * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
             */
            sequence?: number;
            /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
            topic?: string;
            /**
             * Format: uuid
             * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
             */
            tx?: string;
            /**
             * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
             * @enum {string}
             */
            type?:
              | "transaction_submitted"
              | "message_confirmed"
              | "message_rejected"
              | "datatype_confirmed"
              | "identity_confirmed"
              | "identity_updated"
              | "token_pool_confirmed"
              | "token_pool_op_failed"
              | "token_transfer_confirmed"
              | "token_transfer_op_failed"
              | "token_approval_confirmed"
              | "token_approval_op_failed"
              | "contract_interface_confirmed"
              | "contract_api_confirmed"
              | "blockchain_event_received"
              | "blockchain_invoke_op_succeeded"
              | "blockchain_invoke_op_failed"
              | "blockchain_contract_deploy_op_succeeded"
              | "blockchain_contract_deploy_op_failed";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets an event by its ID */
  getEventByIDNamespace: {
    parameters: {
      path: {
        /** The event ID */
        eid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the record that this item references in its 'reference' field */
        fetchreference?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
             */
            correlator?: string;
            /**
             * Format: date-time
             * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID assigned to this event by your local FireFly node
             */
            id?: string;
            /** @description The namespace of the event. Your application must subscribe to events within a namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
             */
            reference?: string;
            /**
             * Format: int64
             * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
             */
            sequence?: number;
            /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
            topic?: string;
            /**
             * Format: uuid
             * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
             */
            tx?: string;
            /**
             * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
             * @enum {string}
             */
            type?:
              | "transaction_submitted"
              | "message_confirmed"
              | "message_rejected"
              | "datatype_confirmed"
              | "identity_confirmed"
              | "identity_updated"
              | "token_pool_confirmed"
              | "token_pool_op_failed"
              | "token_transfer_confirmed"
              | "token_transfer_op_failed"
              | "token_approval_confirmed"
              | "token_approval_op_failed"
              | "contract_interface_confirmed"
              | "contract_api_confirmed"
              | "blockchain_event_received"
              | "blockchain_invoke_op_succeeded"
              | "blockchain_invoke_op_failed"
              | "blockchain_contract_deploy_op_succeeded"
              | "blockchain_contract_deploy_op_failed";
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of groups */
  getGroupsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        ledger?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time when the group was first used to send a message in the network
             */
            created?: string;
            /**
             * Format: byte
             * @description The identifier hash of this group. Derived from the name and group members
             */
            hash?: string;
            /** @description The local namespace of the group */
            localNamespace?: string;
            /** @description The list of members in this privacy group */
            members?: {
              /** @description The DID of the group member */
              identity?: string;
              /**
               * Format: uuid
               * @description The UUID of the node that receives a copy of the off-chain message for the identity
               */
              node?: string;
            }[];
            /**
             * Format: uuid
             * @description The message used to broadcast this group privately to the members
             */
            message?: string;
            /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
            name?: string;
            /** @description The namespace of the group within the multiparty network */
            namespace?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a group by its ID (hash) */
  getGroupByHashNamespace: {
    parameters: {
      path: {
        /** The hash of the group */
        hash: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time when the group was first used to send a message in the network
             */
            created?: string;
            /**
             * Format: byte
             * @description The identifier hash of this group. Derived from the name and group members
             */
            hash?: string;
            /** @description The local namespace of the group */
            localNamespace?: string;
            /** @description The list of members in this privacy group */
            members?: {
              /** @description The DID of the group member */
              identity?: string;
              /**
               * Format: uuid
               * @description The UUID of the node that receives a copy of the off-chain message for the identity
               */
              node?: string;
            }[];
            /**
             * Format: uuid
             * @description The message used to broadcast this group privately to the members
             */
            message?: string;
            /** @description The optional name of the group, allowing multiple unique groups to exist with the same list of recipients */
            name?: string;
            /** @description The namespace of the group within the multiparty network */
            namespace?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of all identities that have been registered in the namespace */
  getIdentitiesNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Registers a new identity in the network */
  postNewIdentityNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the identity. Part of the updatable profile information of an identity */
          description?: string;
          /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
          key?: string;
          /** @description The name of the identity. The name must be unique within the type and namespace */
          name?: string;
          /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
          parent?: string;
          /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
          profile?: { [key: string]: any };
          /** @description The type of the identity */
          type?: string;
        };
      };
    };
  };
  /** Gets an identity by its DID */
  getIdentityByDIDNamespace: {
    parameters: {
      path: {
        /** The identity DID */
        did: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets an identity by its ID */
  getIdentityByIDNamespace: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Updates an identity */
  patchUpdateIdentityNamespace: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the identity. Part of the updatable profile information of an identity */
          description?: string;
          /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
          profile?: { [key: string]: any };
        };
      };
    };
  };
  /** Gets the DID for an identity based on its ID */
  getIdentityDIDNamespace: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description See https://www.w3.org/TR/did-core/#json-ld */
            "@context"?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            authentication?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            id?: string;
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            verificationMethod?: {
              /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
              blockchainAcountId?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              controller?: string;
              /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
              dataExchangePeerID?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              id?: string;
              /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
              mspIdentityString?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              type?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the verifiers for an identity */
  getIdentityVerifiersNamespace: {
    parameters: {
      path: {
        /** The identity ID, which is a UUID generated by FireFly */
        iid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        identity?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        value?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time this verifier was created on this node
             */
            created?: string;
            /**
             * Format: byte
             * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity that has claimed this verifier
             */
            identity?: string;
            /** @description The namespace of the verifier */
            namespace?: string;
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of messages */
  getMsgsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** Fetch the data and include it in the messages returned */
        fetchdata?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        author?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        cid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        confirmed?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        datahash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        group?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pins?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        rejectreason?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        state?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tag?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topics?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "txparent.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        txtype?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a message by its ID */
  getMsgByIDNamespace: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** Fetch the data and include it in the messages returned */
        fetchdata?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description An optional in-line hash reference to a previously uploaded binary data blob */
              blob?: {
                /**
                 * Format: byte
                 * @description The hash of the binary blob data
                 */
                hash?: string;
                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                name?: string;
                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                path?: string;
                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                public?: string;
                /**
                 * Format: int64
                 * @description The size of the binary data
                 */
                size?: number;
              };
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the list of data items that are attached to a message */
  getMsgDataNamespace: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An optional hash reference to a binary blob attachment */
            blob?: {
              /**
               * Format: byte
               * @description The hash of the binary blob data
               */
              hash?: string;
              /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
              name?: string;
              /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
              path?: string;
              /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
              public?: string;
              /**
               * Format: int64
               * @description The size of the binary data
               */
              size?: number;
            };
            /**
             * Format: date-time
             * @description The creation time of the data resource
             */
            created?: string;
            /** @description The optional datatype to use of validation of this data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: byte
             * @description The hash of the data resource. Derived from the value and the hash of any binary blob attachment
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the data resource
             */
            id?: string;
            /** @description The namespace of the data resource */
            namespace?: string;
            /** @description If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
            public?: string;
            /** @description The data validator type */
            validator?: string;
            /** @description The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment */
            value?: any;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets the list of events for a message */
  getMsgEventsNamespace: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        correlator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        reference?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        topic?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tx?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description For message events, this is the 'header.cid' field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool
             */
            correlator?: string;
            /**
             * Format: date-time
             * @description The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the 'sequence' field should be used instead of the 'created' field for querying events in the exact order they are delivered to applications
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID assigned to this event by your local FireFly node
             */
            id?: string;
            /** @description The namespace of the event. Your application must subscribe to events within a namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset
             */
            reference?: string;
            /**
             * Format: int64
             * @description A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp)
             */
            sequence?: number;
            /** @description A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types */
            topic?: string;
            /**
             * Format: uuid
             * @description The UUID of a transaction that is event is part of. Not all events are part of a transaction
             */
            tx?: string;
            /**
             * @description All interesting activity in FireFly is emitted as a FireFly event, of a given type. The 'type' combined with the 'reference' can be used to determine how to process the event within your application
             * @enum {string}
             */
            type?:
              | "transaction_submitted"
              | "message_confirmed"
              | "message_rejected"
              | "datatype_confirmed"
              | "identity_confirmed"
              | "identity_updated"
              | "token_pool_confirmed"
              | "token_pool_op_failed"
              | "token_transfer_confirmed"
              | "token_transfer_op_failed"
              | "token_approval_confirmed"
              | "token_approval_op_failed"
              | "contract_interface_confirmed"
              | "contract_api_confirmed"
              | "blockchain_event_received"
              | "blockchain_invoke_op_succeeded"
              | "blockchain_invoke_op_failed"
              | "blockchain_contract_deploy_op_succeeded"
              | "blockchain_contract_deploy_op_failed";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets the transaction for a message */
  getMsgTxnNamespace: {
    parameters: {
      path: {
        /** The message ID */
        msgid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
            blockchainIds?: string[];
            /**
             * Format: date-time
             * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction
             */
            id?: string;
            /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
            idempotencyKey?: string;
            /** @description The namespace of the FireFly transaction */
            namespace?: string;
            /**
             * @description The type of the FireFly transaction
             * @enum {string}
             */
            type?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
          };
        };
      };
      default: unknown;
    };
  };
  /** Broadcasts a message to all members in the network */
  postNewMessageBroadcastNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
          data?: {
            /** @description The optional datatype to use for validation of the in-line data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: uuid
             * @description The UUID of the referenced data resource
             */
            id?: string;
            /** @description The data validator type to use for in-line data */
            validator?: string;
            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
            value?: any;
          }[];
          /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
          group?: {
            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
            members?: {
              /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
              identity?: string;
              /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
              node?: string;
            }[];
            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
            name?: string;
          };
          /** @description The message header contains all fields that are used to build the message hash */
          header?: {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: uuid
             * @description The correlation ID of the message. Set this when a message is a response to another message
             */
            cid?: string;
            /**
             * Format: byte
             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
             */
            group?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The message tag indicates the purpose of the message to the applications that process it */
            tag?: string;
            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
            topics?: string[];
            /**
             * @description The type of transaction used to order/deliver this message
             * @enum {string}
             */
            txtype?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
            /**
             * @description The type of the message
             * @enum {string}
             */
            type?:
              | "definition"
              | "broadcast"
              | "private"
              | "groupinit"
              | "transfer_broadcast"
              | "transfer_private"
              | "approval_broadcast"
              | "approval_private";
          };
          /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Privately sends a message to one or more members in the network */
  postNewMessagePrivateNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description The list of data elements attached to the message */
            data?: {
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
            }[];
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
          data?: {
            /** @description The optional datatype to use for validation of the in-line data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: uuid
             * @description The UUID of the referenced data resource
             */
            id?: string;
            /** @description The data validator type to use for in-line data */
            validator?: string;
            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
            value?: any;
          }[];
          /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
          group?: {
            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
            members?: {
              /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
              identity?: string;
              /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
              node?: string;
            }[];
            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
            name?: string;
          };
          /** @description The message header contains all fields that are used to build the message hash */
          header?: {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: uuid
             * @description The correlation ID of the message. Set this when a message is a response to another message
             */
            cid?: string;
            /**
             * Format: byte
             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
             */
            group?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The message tag indicates the purpose of the message to the applications that process it */
            tag?: string;
            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
            topics?: string[];
            /**
             * @description The type of transaction used to order/deliver this message
             * @enum {string}
             */
            txtype?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
            /**
             * @description The type of the message
             * @enum {string}
             */
            type?:
              | "definition"
              | "broadcast"
              | "private"
              | "groupinit"
              | "transfer_broadcast"
              | "transfer_private"
              | "approval_broadcast"
              | "approval_private";
          };
          /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Sends a message with a blocking HTTP request, waits for a reply to that message, then sends the reply as the HTTP response. */
  postNewMessageRequestReplyNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch in which the message was pinned/transferred
             */
            batch?: string;
            /**
             * Format: date-time
             * @description The timestamp of when the message was confirmed/rejected
             */
            confirmed?: string;
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description An optional in-line hash reference to a previously uploaded binary data blob */
              blob?: {
                /**
                 * Format: byte
                 * @description The hash of the binary blob data
                 */
                hash?: string;
                /** @description The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search */
                name?: string;
                /** @description If a name is specified, this field stores the '/' prefixed and separated path extracted from the full name */
                path?: string;
                /** @description If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) */
                public?: string;
                /**
                 * Format: int64
                 * @description The size of the binary data
                 */
                size?: number;
              };
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: byte
               * @description The hash of the referenced data
               */
              hash?: string;
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /**
             * Format: byte
             * @description The hash of the message. Derived from the header, which includes the data hash
             */
            hash?: string;
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: date-time
               * @description The creation time of the message
               */
              created?: string;
              /**
               * Format: byte
               * @description A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message
               */
              datahash?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /**
               * Format: uuid
               * @description The UUID of the message. Unique to each message
               */
              id?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The namespace of the message within the multiparty network */
              namespace?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /** @description The parent transaction that originally triggered this message */
              txparent?: {
                /**
                 * Format: uuid
                 * @description The UUID of the FireFly transaction
                 */
                id?: string;
                /** @description The type of the FireFly transaction */
                type?: string;
              };
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
            /** @description The local namespace of the message */
            localNamespace?: string;
            /** @description For private messages, a unique pin hash:nonce is assigned for each topic */
            pins?: string[];
            /** @description If a message was rejected, provides details on the rejection reason */
            rejectReason?: string;
            /**
             * @description The current state of the message
             * @enum {string}
             */
            state?:
              | "staged"
              | "ready"
              | "sent"
              | "pending"
              | "confirmed"
              | "rejected";
            /**
             * Format: uuid
             * @description The ID of the transaction used to order/deliver this message
             */
            txid?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
          data?: {
            /** @description The optional datatype to use for validation of the in-line data */
            datatype?: {
              /** @description The name of the datatype */
              name?: string;
              /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
              version?: string;
            };
            /**
             * Format: uuid
             * @description The UUID of the referenced data resource
             */
            id?: string;
            /** @description The data validator type to use for in-line data */
            validator?: string;
            /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
            value?: any;
          }[];
          /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
          group?: {
            /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
            members?: {
              /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
              identity?: string;
              /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
              node?: string;
            }[];
            /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
            name?: string;
          };
          /** @description The message header contains all fields that are used to build the message hash */
          header?: {
            /** @description The DID of identity of the submitter */
            author?: string;
            /**
             * Format: uuid
             * @description The correlation ID of the message. Set this when a message is a response to another message
             */
            cid?: string;
            /**
             * Format: byte
             * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
             */
            group?: string;
            /** @description The on-chain signing key used to sign the transaction */
            key?: string;
            /** @description The message tag indicates the purpose of the message to the applications that process it */
            tag?: string;
            /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
            topics?: string[];
            /**
             * @description The type of transaction used to order/deliver this message
             * @enum {string}
             */
            txtype?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
            /**
             * @description The type of the message
             * @enum {string}
             */
            type?:
              | "definition"
              | "broadcast"
              | "private"
              | "groupinit"
              | "transfer_broadcast"
              | "transfer_private"
              | "approval_broadcast"
              | "approval_private";
          };
          /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
          idempotencyKey?: string;
        };
      };
    };
  };
  /** Notify all nodes in the network of a new governance action */
  postNetworkActionNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * @description The action to be performed
             * @enum {string}
             */
            type?: "terminate";
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The action to be performed
           * @enum {string}
           */
          type?: "terminate";
        };
      };
    };
  };
  /** Gets a DID document by its DID */
  getNetworkDIDDocByDIDNamespace: {
    parameters: {
      path: {
        /** The identity DID */
        did: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description See https://www.w3.org/TR/did-core/#json-ld */
            "@context"?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            authentication?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            id?: string;
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            verificationMethod?: {
              /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
              blockchainAcountId?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              controller?: string;
              /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
              dataExchangePeerID?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              id?: string;
              /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
              mspIdentityString?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              type?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the list of identities in the network (deprecated - use /identities instead of /network/identities */
  getNetworkIdentitiesNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets an identity by its DID */
  getNetworkIdentityByDIDNamespace: {
    parameters: {
      path: {
        /** The identity DID */
        did: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of nodes in the network */
  getNetworkNodesNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets information about a specific node in the network */
  getNetworkNodeNamespace: {
    parameters: {
      path: {
        /** The name or ID of the node */
        nameOrId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Instructs this FireFly node to register itself on the network */
  postNodesSelfNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Gets a list of orgs in the network */
  getNetworkOrgsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Registers a new org in the network */
  postNewOrganizationNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the identity. Part of the updatable profile information of an identity */
          description?: string;
          /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
          key?: string;
          /** @description The name of the identity. The name must be unique within the type and namespace */
          name?: string;
          /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
          parent?: string;
          /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
          profile?: { [key: string]: any };
          /** @description The type of the identity */
          type?: string;
        };
      };
    };
  };
  /** Gets information about a specific org in the network */
  getNetworkOrgNamespace: {
    parameters: {
      path: {
        /** The name or ID of the org */
        nameOrId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Instructs this FireFly node to register its org on the network */
  postNewOrganizationSelfNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Queries the list of next-pins that determine the next masked message sequence for each member of a privacy group, on each context/topic */
  getNextPinsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        context?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        identity?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        nonce?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: byte
             * @description The context the next-pin applies to - the hash of the privacy group-hash + topic. The group-hash is only known to the participants (can itself contain a salt in the group-name). This context is combined with the member and nonce to determine the final hash that is written on-chain
             */
            context?: string;
            /**
             * Format: byte
             * @description The unique masked pin string
             */
            hash?: string;
            /** @description The member of the privacy group the next-pin applies to */
            identity?: string;
            /** @description The namespace of the next-pin */
            namespace?: string;
            /**
             * Format: int64
             * @description The numeric index - which is monotonically increasing for each member of the privacy group
             */
            nonce?: number;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a a list of operations */
  getOpsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        error?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        input?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        output?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        plugin?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        retry?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        status?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tx?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets an operation by ID */
  getOpByIDNamespace: {
    parameters: {
      path: {
        /** The operation ID key to get */
        opid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return additional status information if available */
        fetchstatus?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Additional detailed information about an operation provided by the connector */
            detail?: any;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Retries a failed operation */
  postOpRetryNamespace: {
    parameters: {
      path: {
        /** The UUID of the operation */
        opid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Queries the list of pins received from the blockchain */
  getPinsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        dispatched?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        index?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        masked?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch of messages this pin is part of
             */
            batch?: string;
            /**
             * Format: byte
             * @description The manifest hash batch of messages this pin is part of
             */
            batchHash?: string;
            /**
             * Format: date-time
             * @description The time the FireFly node created the pin
             */
            created?: string;
            /** @description Once true, this pin has been processed and will not be processed again */
            dispatched?: boolean;
            /**
             * Format: byte
             * @description The hash represents a topic within a message in the batch. If a message has multiple topics, then multiple pins are created. If the message is private, the hash is masked for privacy
             */
            hash?: string;
            /**
             * Format: int64
             * @description The index of this pin within the batch. One pin is created for each topic, of each message in the batch
             */
            index?: number;
            /** @description True if the pin is for a private message, and hence is masked with the group ID and salted with a nonce so observers of the blockchain cannot use pin hash to match this transaction to other transactions or participants */
            masked?: boolean;
            /** @description The namespace of the pin */
            namespace?: string;
            /**
             * Format: int64
             * @description The order of the pin in the local FireFly database, which matches the order in which pins were delivered to FireFly by the blockchain connector event stream
             */
            sequence?: number;
            /** @description The blockchain signing key that submitted this transaction, as passed through to FireFly by the smart contract that emitted the blockchain event */
            signer?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Force a rewind of the event aggregator to a previous position, to re-evaluate (and possibly dispatch) that pin and others after it. Only accepts a sequence or batch ID for a currently undispatched pin */
  postPinsRewindNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
             */
            batch?: string;
            /**
             * Format: int64
             * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
             */
            sequence?: number;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: uuid
           * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
           */
          batch?: string;
          /**
           * Format: int64
           * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
           */
          sequence?: number;
        };
      };
    };
  };
  /** Gets the status of this namespace */
  getStatusNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Information about the multi-party system configured on this namespace */
            multiparty?: {
              /** @description Information about the multi-party smart contract configured for this namespace */
              contract?: {
                /** @description The currently active FireFly smart contract */
                active?: {
                  /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                  firstEvent?: string;
                  /** @description The index of this contract in the config file */
                  index?: number;
                  /** @description Additional info about the current status of the multi-party contract */
                  info?: {
                    /** @description The identifier for the final blockchain event received from this contract before termination */
                    finalEvent?: string;
                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                    subscription?: string;
                    /** @description The version of this multiparty contract */
                    version?: number;
                  };
                  /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                  location?: any;
                };
                /** @description Previously-terminated FireFly smart contracts */
                terminated?: {
                  /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                  firstEvent?: string;
                  /** @description The index of this contract in the config file */
                  index?: number;
                  /** @description Additional info about the current status of the multi-party contract */
                  info?: {
                    /** @description The identifier for the final blockchain event received from this contract before termination */
                    finalEvent?: string;
                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                    subscription?: string;
                    /** @description The version of this multiparty contract */
                    version?: number;
                  };
                  /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                  location?: any;
                }[];
              };
              /** @description Whether multi-party mode is enabled for this namespace */
              enabled?: boolean;
            };
            /** @description The namespace that this status applies to */
            namespace?: {
              /**
               * Format: date-time
               * @description The time the namespace was created
               */
              created?: string;
              /** @description A description of the namespace */
              description?: string;
              /** @description The local namespace name */
              name?: string;
              /** @description The shared namespace name within the multiparty network */
              networkName?: string;
            };
            /** @description Details of the local node */
            node?: {
              /**
               * Format: uuid
               * @description The UUID of the node, if registered
               */
              id?: string;
              /** @description The name of this node, as specified in the local configuration */
              name?: string;
              /** @description Whether the node has been successfully registered */
              registered?: boolean;
            };
            /** @description Details of the root organization identity registered for this namespace on the local node */
            org?: {
              /** @description The DID of the organization identity, if registered */
              did?: string;
              /**
               * Format: uuid
               * @description The UUID of the organization, if registered
               */
              id?: string;
              /** @description The name of the node operator organization, as specified in the local configuration */
              name?: string;
              /** @description Whether the organization has been successfully registered */
              registered?: boolean;
              /** @description Array of verifiers (blockchain keys) owned by this identity */
              verifiers?: {
                /**
                 * @description The type of the verifier
                 * @enum {string}
                 */
                type?:
                  | "ethereum_address"
                  | "tezos_address"
                  | "fabric_msp_id"
                  | "dx_peer_id";
                /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                value?: string;
              }[];
            };
            /** @description Information about plugins configured on this namespace */
            plugins?: {
              /** @description The blockchain plugins on this namespace */
              blockchain?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The data exchange plugins on this namespace */
              dataExchange?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The database plugins on this namespace */
              database?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The event plugins on this namespace */
              events?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The identity plugins on this namespace */
              identity?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The shared storage plugins on this namespace */
              sharedStorage?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The token plugins on this namespace */
              tokens?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
            };
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the status of the batch manager */
  getStatusBatchManagerNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An array of currently active batch processors */
            processors?: {
              /** @description The type of dispatcher for this processor */
              dispatcher?: string;
              /** @description The name of the processor, which includes details of the attributes of message are allocated to this processor */
              name?: string;
              /** @description The flush status for this batch processor */
              status?: {
                /**
                 * Format: int64
                 * @description The average byte size of each batch
                 */
                averageBatchBytes?: number;
                /**
                 * Format: double
                 * @description The average number of data attachments included in each batch
                 */
                averageBatchData?: number;
                /**
                 * Format: double
                 * @description The average number of messages included in each batch
                 */
                averageBatchMessages?: number;
                /**
                 * Format: int64
                 * @description The average amount of time spent flushing each batch
                 */
                averageFlushTimeMS?: number;
                /** @description True if the batch flush is in a retry loop, due to errors being returned by the plugins */
                blocked?: boolean;
                /**
                 * Format: uuid
                 * @description If a flush is in progress, this is the UUID of the batch being flushed
                 */
                flushing?: string;
                /** @description The last error received by this batch processor while flushing */
                lastFlushError?: string;
                /**
                 * Format: date-time
                 * @description The time of the last flush
                 */
                lastFlushErrorTime?: string;
                /**
                 * Format: date-time
                 * @description The last time a flush was performed
                 */
                lastFlushStartTime?: string;
                /**
                 * Format: int64
                 * @description The total count of batches flushed by this processor since it started
                 */
                totalBatches?: number;
                /**
                 * Format: int64
                 * @description The total count of error flushed encountered by this processor since it started
                 */
                totalErrors?: number;
              };
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of subscriptions */
  getSubscriptionsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        events?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        filters?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        options?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        transport?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Update an existing subscription */
  putSubscriptionNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Server-side filter to apply to events */
          filter?: {
            /** @description Deprecated: Please use 'message.author' instead */
            author?: string;
            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
            blockchainevent?: {
              /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
              listener?: string;
              /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
              name?: string;
            };
            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
            events?: string;
            /** @description Deprecated: Please use 'message.group' instead */
            group?: string;
            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
            message?: {
              /** @description Regular expression to apply to the message 'header.author' field */
              author?: string;
              /** @description Regular expression to apply to the message 'header.group' field */
              group?: string;
              /** @description Regular expression to apply to the message 'header.tag' field */
              tag?: string;
            };
            /** @description Deprecated: Please use 'message.tag' instead */
            tag?: string;
            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
            topic?: string;
            /** @description Deprecated: Please use 'topic' instead */
            topics?: string;
            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
            transaction?: {
              /** @description Regular expression to apply to the transaction 'type' field */
              type?: string;
            };
          };
          /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
          name?: string;
          /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
          namespace?: string;
          /** @description Subscription options */
          options?: {
            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
            batch?: boolean;
            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
            batchTimeout?: string;
            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
            fastack?: boolean;
            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
            firstEvent?: string;
            /** @description Webhooks only: Static headers to set on the webhook request */
            headers?: { [key: string]: string };
            /** @description Webhooks only: a set of options for HTTP */
            httpOptions?: {
              /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
              connectionTimeout?: string;
              /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
              expectContinueTimeout?: string;
              /** @description The max duration to hold a HTTP keepalive connection between calls */
              idleTimeout?: string;
              /** @description The max number of idle connections to hold pooled */
              maxIdleConns?: number;
              /** @description HTTP proxy URL to use for outbound requests to the webhook */
              proxyURL?: string;
              /** @description The max duration to hold a TLS handshake alive */
              requestTimeout?: string;
              /** @description The max duration to hold a TLS handshake alive */
              tlsHandshakeTimeout?: string;
            };
            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
            input?: {
              /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
              body?: string;
              /** @description A top-level property of the first data input, to use for headers */
              headers?: string;
              /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
              path?: string;
              /** @description A top-level property of the first data input, to use for query parameters */
              query?: string;
              /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
              replytx?: string;
            };
            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
            json?: boolean;
            /** @description Webhooks only: HTTP method to invoke. Default=POST */
            method?: string;
            /** @description Webhooks only: Static query params to set on the webhook request */
            query?: { [key: string]: string };
            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
            readAhead?: number;
            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
            reply?: boolean;
            /** @description Webhooks only: The tag to set on the reply message */
            replytag?: string;
            /** @description Webhooks only: The transaction type to set on the reply message */
            replytx?: string;
            /** @description Webhooks only: a set of options for retrying the webhook call */
            retry?: {
              /** @description Number of times to retry the webhook call in case of failure */
              count?: number;
              /** @description Enables retry on HTTP calls, defaults to false */
              enabled?: boolean;
              /** @description Initial delay between retries when we retry the webhook call */
              initialDelay?: string;
              /** @description Max delay between retries when we retry the webhookcall */
              maxDelay?: string;
            };
            /** @description The name of an existing TLS configuration associated to the namespace to use */
            tlsConfigName?: string;
            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
            url?: string;
            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
            withData?: boolean;
          };
          /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
          transport?: string;
        };
      };
    };
  };
  /** Creates a new subscription for an application to receive events from FireFly */
  postNewSubscriptionNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Server-side filter to apply to events */
          filter?: {
            /** @description Deprecated: Please use 'message.author' instead */
            author?: string;
            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
            blockchainevent?: {
              /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
              listener?: string;
              /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
              name?: string;
            };
            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
            events?: string;
            /** @description Deprecated: Please use 'message.group' instead */
            group?: string;
            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
            message?: {
              /** @description Regular expression to apply to the message 'header.author' field */
              author?: string;
              /** @description Regular expression to apply to the message 'header.group' field */
              group?: string;
              /** @description Regular expression to apply to the message 'header.tag' field */
              tag?: string;
            };
            /** @description Deprecated: Please use 'message.tag' instead */
            tag?: string;
            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
            topic?: string;
            /** @description Deprecated: Please use 'topic' instead */
            topics?: string;
            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
            transaction?: {
              /** @description Regular expression to apply to the transaction 'type' field */
              type?: string;
            };
          };
          /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
          name?: string;
          /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
          namespace?: string;
          /** @description Subscription options */
          options?: {
            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
            batch?: boolean;
            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
            batchTimeout?: string;
            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
            fastack?: boolean;
            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
            firstEvent?: string;
            /** @description Webhooks only: Static headers to set on the webhook request */
            headers?: { [key: string]: string };
            /** @description Webhooks only: a set of options for HTTP */
            httpOptions?: {
              /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
              connectionTimeout?: string;
              /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
              expectContinueTimeout?: string;
              /** @description The max duration to hold a HTTP keepalive connection between calls */
              idleTimeout?: string;
              /** @description The max number of idle connections to hold pooled */
              maxIdleConns?: number;
              /** @description HTTP proxy URL to use for outbound requests to the webhook */
              proxyURL?: string;
              /** @description The max duration to hold a TLS handshake alive */
              requestTimeout?: string;
              /** @description The max duration to hold a TLS handshake alive */
              tlsHandshakeTimeout?: string;
            };
            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
            input?: {
              /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
              body?: string;
              /** @description A top-level property of the first data input, to use for headers */
              headers?: string;
              /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
              path?: string;
              /** @description A top-level property of the first data input, to use for query parameters */
              query?: string;
              /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
              replytx?: string;
            };
            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
            json?: boolean;
            /** @description Webhooks only: HTTP method to invoke. Default=POST */
            method?: string;
            /** @description Webhooks only: Static query params to set on the webhook request */
            query?: { [key: string]: string };
            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
            readAhead?: number;
            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
            reply?: boolean;
            /** @description Webhooks only: The tag to set on the reply message */
            replytag?: string;
            /** @description Webhooks only: The transaction type to set on the reply message */
            replytx?: string;
            /** @description Webhooks only: a set of options for retrying the webhook call */
            retry?: {
              /** @description Number of times to retry the webhook call in case of failure */
              count?: number;
              /** @description Enables retry on HTTP calls, defaults to false */
              enabled?: boolean;
              /** @description Initial delay between retries when we retry the webhook call */
              initialDelay?: string;
              /** @description Max delay between retries when we retry the webhookcall */
              maxDelay?: string;
            };
            /** @description The name of an existing TLS configuration associated to the namespace to use */
            tlsConfigName?: string;
            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
            url?: string;
            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
            withData?: boolean;
          };
          /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
          transport?: string;
        };
      };
    };
  };
  /** Gets a subscription by its ID */
  getSubscriptionByIDNamespace: {
    parameters: {
      path: {
        /** The subscription ID */
        subid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When set, the API will return additional status information if available */
        fetchstatus?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Deletes a subscription */
  deleteSubscriptionNamespace: {
    parameters: {
      path: {
        /** The subscription ID */
        subid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of token accounts */
  getTokenAccountsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain signing identity this balance applies to */
            key?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of token pools that contain a given token account key */
  getTokenAccountPoolsNamespace: {
    parameters: {
      path: {
        /** The key for the token account. The exact format may vary based on the token connector use */
        key: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID the token pool this balance entry applies to
             */
            pool?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of token approvals */
  getTokenApprovalsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        active?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        approved?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainevent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        localid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        messagehash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        operator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        protocolid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        subject?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
            active?: boolean;
            /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
            approved?: boolean;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the token approval
             */
            created?: string;
            /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token approval, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the approval, which must match the namespace of the token pool */
            namespace?: string;
            /** @description The blockchain identity that is granted the approval */
            operator?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this approval applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
            subject?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a token approval */
  postTokenApprovalNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
            active?: boolean;
            /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
            approved?: boolean;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the token approval
             */
            created?: string;
            /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token approval, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the approval, which must match the namespace of the token pool */
            namespace?: string;
            /** @description The blockchain identity that is granted the approval */
            operator?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this approval applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
            subject?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
            active?: boolean;
            /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
            approved?: boolean;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the token approval
             */
            created?: string;
            /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token approval, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the approval, which must match the namespace of the token pool */
            namespace?: string;
            /** @description The blockchain identity that is granted the approval */
            operator?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this approval applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
            subject?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
          approved?: boolean;
          /** @description Input only field, with token connector specific configuration of the approval.  See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the approval, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the approval */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The blockchain identity that is granted the approval */
          operator?: string;
          /**
           * Format: uuid
           * @description The UUID the token pool this approval applies to
           */
          pool?: string;
        };
      };
    };
  };
  /** Gets a list of token balances */
  getTokenBalancesNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        balance?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tokenindex?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        uri?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The numeric balance. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when interpreting the balance. For example, with 18 decimals a fractional balance of 10.234 will be returned as 10,234,000,000,000,000,000 */
            balance?: string;
            /** @description The token connector that is responsible for the token pool of this balance entry */
            connector?: string;
            /** @description The blockchain signing identity this balance applies to */
            key?: string;
            /** @description The namespace of the token pool for this balance entry */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this balance entry applies to
             */
            pool?: string;
            /** @description The index of the token within the pool that this balance applies to */
            tokenIndex?: string;
            /**
             * Format: date-time
             * @description The last time the balance was updated by applying a transfer event
             */
            updated?: string;
            /** @description The URI of the token this balance entry applies to */
            uri?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Burns some tokens */
  postTokenBurnNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
          amount?: string;
          /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description The source account for the transfer. On input defaults to the value of 'key' */
          from?: string;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The name or UUID of a token pool */
          pool?: string;
          /** @description The target account for the transfer. On input defaults to the value of 'key' */
          to?: string;
          /** @description The index of the token within the pool that this transfer applies to */
          tokenIndex?: string;
          /** @description The URI of the token this transfer applies to */
          uri?: string;
        };
      };
    };
  };
  /** Gets the list of token connectors currently in use */
  getTokenConnectorsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The name of the token connector, as configured in the FireFly core configuration file */
            name?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Mints some tokens */
  postTokenMintNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
          amount?: string;
          /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description The source account for the transfer. On input defaults to the value of 'key' */
          from?: string;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The name or UUID of a token pool */
          pool?: string;
          /** @description The target account for the transfer. On input defaults to the value of 'key' */
          to?: string;
          /** @description The index of the token within the pool that this transfer applies to */
          tokenIndex?: string;
          /** @description The URI of the token this transfer applies to */
          uri?: string;
        };
      };
    };
  };
  /** Gets a list of token pools */
  getTokenPoolsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        active?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        decimals?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interfaceformat?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        locator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        networkname?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        published?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        standard?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        symbol?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new token pool */
  postTokenPoolNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
        /** When true the definition will be published to all other members of the multiparty network */
        publish?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Input only field, with token connector specific configuration of the pool, such as an existing Ethereum address and block number to used to index the pool. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
          connector?: string;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
          key?: string;
          /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
          name?: string;
          /** @description The published name of the token pool within the multiparty network */
          networkName?: string;
          /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
          symbol?: string;
          /**
           * @description The type of token the pool contains, such as fungible/non-fungible
           * @enum {string}
           */
          type?: "fungible" | "nonfungible";
        };
      };
    };
  };
  /** Gets a token pool by its name or its ID */
  getTokenPoolByNameOrIDNamespace: {
    parameters: {
      path: {
        /** The token pool name or ID */
        nameOrId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      default: unknown;
    };
  };
  /** Delete a token pool */
  deleteTokenPoolNamespace: {
    parameters: {
      path: {
        /** The token pool name or ID */
        nameOrId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Publish a token pool to all other members of the multiparty network */
  postTokenPoolPublishNamespace: {
    parameters: {
      path: {
        /** The token pool name or ID */
        nameOrId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
          networkName?: string;
        };
      };
    };
  };
  /** Gets a list of token transfers */
  getTokenTransfersNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** The sending or receiving token account for a token transfer */
        fromOrTo?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        amount?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainevent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        from?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        localid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        messagehash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        protocolid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        to?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tokenindex?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        uri?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Transfers some tokens */
  postTokenTransferNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
          amount?: string;
          /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description The source account for the transfer. On input defaults to the value of 'key' */
          from?: string;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The name or UUID of a token pool */
          pool?: string;
          /** @description The target account for the transfer. On input defaults to the value of 'key' */
          to?: string;
          /** @description The index of the token within the pool that this transfer applies to */
          tokenIndex?: string;
          /** @description The URI of the token this transfer applies to */
          uri?: string;
        };
      };
    };
  };
  /** Gets a token transfer by its ID */
  getTokenTransferByIDNamespace: {
    parameters: {
      path: {
        /** The token transfer ID */
        transferId: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of transactions */
  getTxnsNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainids?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
            blockchainIds?: string[];
            /**
             * Format: date-time
             * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction
             */
            id?: string;
            /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
            idempotencyKey?: string;
            /** @description The namespace of the FireFly transaction */
            namespace?: string;
            /**
             * @description The type of the FireFly transaction
             * @enum {string}
             */
            type?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a transaction by its ID */
  getTxnByIDNamespace: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainids?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
            blockchainIds?: string[];
            /**
             * Format: date-time
             * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction
             */
            id?: string;
            /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
            idempotencyKey?: string;
            /** @description The namespace of the FireFly transaction */
            namespace?: string;
            /**
             * @description The type of the FireFly transaction
             * @enum {string}
             */
            type?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list blockchain events for a specific transaction */
  getTxnBlockchainEventsNamespace: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID assigned to the event by FireFly
             */
            id?: string;
            /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
            info?: { [key: string]: any };
            /**
             * Format: uuid
             * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
             */
            listener?: string;
            /** @description The name of the event in the blockchain smart contract */
            name?: string;
            /** @description The namespace of the listener that detected this blockchain event */
            namespace?: string;
            /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
            output?: { [key: string]: any };
            /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
            protocolId?: string;
            /** @description The blockchain plugin or token service that detected the event */
            source?: string;
            /**
             * Format: date-time
             * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
             */
            timestamp?: string;
            /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
            tx?: {
              /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
              blockchainId?: string;
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of operations in a specific transaction */
  getTxnOpsNamespace: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets the status of a transaction */
  getTxnStatusNamespace: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A set of records describing the activities within the transaction known by the local FireFly node */
            details?: {
              /** @description If an error occurred related to the detail entry, it is included here */
              error?: string;
              /**
               * Format: uuid
               * @description The UUID of the entry referenced by this detail. The type of this record can be inferred from the entry type
               */
              id?: string;
              /** @description Output details for this entry */
              info?: { [key: string]: any };
              /** @description The status of the detail record. Cases where an event is required for completion, but has not arrived yet are marked with a 'pending' record */
              status?: string;
              /** @description A sub-type, such as an operation type, or an event type */
              subtype?: string;
              /**
               * Format: date-time
               * @description The time relevant to when the record was updated, such as the time an event was created, or the last update time of an operation
               */
              timestamp?: string;
              /** @description The type of the transaction status detail record */
              type?: string;
            }[];
            /** @description The overall computed status of the transaction, after analyzing the details during the API call */
            status?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of verifiers */
  getVerifiersNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        identity?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        value?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time this verifier was created on this node
             */
            created?: string;
            /**
             * Format: byte
             * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity that has claimed this verifier
             */
            identity?: string;
            /** @description The namespace of the verifier */
            namespace?: string;
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a verifier by its hash */
  getVerifierByIDNamespace: {
    parameters: {
      path: {
        /** The hash of the verifier */
        hash: string;
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time this verifier was created on this node
             */
            created?: string;
            /**
             * Format: byte
             * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity that has claimed this verifier
             */
            identity?: string;
            /** @description The namespace of the verifier */
            namespace?: string;
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Resolves an input key to a signing key */
  postVerifiersResolveNamespace: {
    parameters: {
      path: {
        /** The namespace which scopes this request */
        ns: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The type of the verifier
           * @enum {string}
           */
          type?:
            | "ethereum_address"
            | "tezos_address"
            | "fabric_msp_id"
            | "dx_peer_id";
          /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
          value?: string;
        };
      };
    };
  };
  /** Notify all nodes in the network of a new governance action */
  postNetworkAction: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * @description The action to be performed
             * @enum {string}
             */
            type?: "terminate";
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The action to be performed
           * @enum {string}
           */
          type?: "terminate";
        };
      };
    };
  };
  /** Gets a DID document by its DID */
  getNetworkDIDDocByDID: {
    parameters: {
      path: {
        /** The identity DID */
        did: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description See https://www.w3.org/TR/did-core/#json-ld */
            "@context"?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            authentication?: string[];
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            id?: string;
            /** @description See https://www.w3.org/TR/did-core/#did-document-properties */
            verificationMethod?: {
              /** @description For blockchains like Ethereum that represent signing identities directly by their public key summarized in an account string */
              blockchainAcountId?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              controller?: string;
              /** @description A string provided by your Data Exchange plugin, that it uses a technology specific mechanism to validate against when messages arrive from this identity */
              dataExchangePeerID?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              id?: string;
              /** @description For Hyperledger Fabric where the signing identity is represented by an MSP identifier (containing X509 certificate DN strings) that were validated by your local MSP */
              mspIdentityString?: string;
              /** @description See https://www.w3.org/TR/did-core/#service-properties */
              type?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the list of identities in the network (deprecated - use /identities instead of /network/identities */
  getNetworkIdentities: {
    parameters: {
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets an identity by its DID */
  getNetworkIdentityByDID: {
    parameters: {
      path: {
        /** The identity DID */
        did: string;
      };
      query: {
        /** When set, the API will return the verifier for this identity */
        fetchverifiers?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
            /** @description The verifiers, such as blockchain signing keys, that have been bound to this identity and can be used to prove data orignates from that identity */
            verifiers?: {
              /**
               * @description The type of the verifier
               * @enum {string}
               */
              type?:
                | "ethereum_address"
                | "tezos_address"
                | "fabric_msp_id"
                | "dx_peer_id";
              /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
              value?: string;
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of nodes in the network */
  getNetworkNodes: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets information about a specific node in the network */
  getNetworkNode: {
    parameters: {
      path: {
        /** The name or ID of the node */
        nameOrId: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Instructs this FireFly node to register itself on the network */
  postNodesSelf: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Gets a list of orgs in the network */
  getNetworkOrgs: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        description?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        did?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.claim"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.update"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "messages.verification"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        parent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        profile?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Registers a new org in the network */
  postNewOrganization: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description A description of the identity. Part of the updatable profile information of an identity */
          description?: string;
          /** @description The blockchain signing key to use to make the claim to the identity. Must be available to the local node to sign the identity claim. Will become a verifier on the established identity */
          key?: string;
          /** @description The name of the identity. The name must be unique within the type and namespace */
          name?: string;
          /** @description On input the parent can be specified directly as the UUID of and existing identity, or as a DID to resolve to that identity, or an organization name. The parent must already have been registered, and its blockchain signing key must be available to the local node to sign the verification */
          parent?: string;
          /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
          profile?: { [key: string]: any };
          /** @description The type of the identity */
          type?: string;
        };
      };
    };
  };
  /** Gets information about a specific org in the network */
  getNetworkOrg: {
    parameters: {
      path: {
        /** The name or ID of the org */
        nameOrId: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Instructs this FireFly node to register its org on the network */
  postNewOrganizationSelf: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The creation time of the identity
             */
            created?: string;
            /** @description A description of the identity. Part of the updatable profile information of an identity */
            description?: string;
            /** @description The DID of the identity. Unique across namespaces within a FireFly network */
            did?: string;
            /**
             * Format: uuid
             * @description The UUID of the identity
             */
            id?: string;
            /** @description References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) */
            messages?: {
              /**
               * Format: uuid
               * @description The UUID of claim message
               */
              claim?: string;
              /**
               * Format: uuid
               * @description The UUID of the most recently applied update message. Unset if no updates have been confirmed
               */
              update?: string;
              /**
               * Format: uuid
               * @description The UUID of claim message. Unset for root organization identities
               */
              verification?: string;
            };
            /** @description The name of the identity. The name must be unique within the type and namespace */
            name?: string;
            /** @description The namespace of the identity. Organization and node identities are always defined in the ff_system namespace */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity. Unset for root organization identities
             */
            parent?: string;
            /** @description A set of metadata for the identity. Part of the updatable profile information of an identity */
            profile?: { [key: string]: any };
            /**
             * @description The type of the identity
             * @enum {string}
             */
            type?: "org" | "node" | "custom";
            /**
             * Format: date-time
             * @description The last update time of the identity profile
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Queries the list of next-pins that determine the next masked message sequence for each member of a privacy group, on each context/topic */
  getNextPins: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        context?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        identity?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        nonce?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: byte
             * @description The context the next-pin applies to - the hash of the privacy group-hash + topic. The group-hash is only known to the participants (can itself contain a salt in the group-name). This context is combined with the member and nonce to determine the final hash that is written on-chain
             */
            context?: string;
            /**
             * Format: byte
             * @description The unique masked pin string
             */
            hash?: string;
            /** @description The member of the privacy group the next-pin applies to */
            identity?: string;
            /** @description The namespace of the next-pin */
            namespace?: string;
            /**
             * Format: int64
             * @description The numeric index - which is monotonically increasing for each member of the privacy group
             */
            nonce?: number;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a a list of operations */
  getOps: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        error?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        input?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        output?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        plugin?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        retry?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        status?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tx?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets an operation by ID */
  getOpByID: {
    parameters: {
      path: {
        /** The operation ID key to get */
        opid: string;
      };
      query: {
        /** When set, the API will return additional status information if available */
        fetchstatus?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Additional detailed information about an operation provided by the connector */
            detail?: any;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Retries a failed operation */
  postOpRetry: {
    parameters: {
      path: {
        /** The UUID of the operation */
        opid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      202: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Queries the list of pins received from the blockchain */
  getPins: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        batch?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        dispatched?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        index?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        masked?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        sequence?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID of the batch of messages this pin is part of
             */
            batch?: string;
            /**
             * Format: byte
             * @description The manifest hash batch of messages this pin is part of
             */
            batchHash?: string;
            /**
             * Format: date-time
             * @description The time the FireFly node created the pin
             */
            created?: string;
            /** @description Once true, this pin has been processed and will not be processed again */
            dispatched?: boolean;
            /**
             * Format: byte
             * @description The hash represents a topic within a message in the batch. If a message has multiple topics, then multiple pins are created. If the message is private, the hash is masked for privacy
             */
            hash?: string;
            /**
             * Format: int64
             * @description The index of this pin within the batch. One pin is created for each topic, of each message in the batch
             */
            index?: number;
            /** @description True if the pin is for a private message, and hence is masked with the group ID and salted with a nonce so observers of the blockchain cannot use pin hash to match this transaction to other transactions or participants */
            masked?: boolean;
            /** @description The namespace of the pin */
            namespace?: string;
            /**
             * Format: int64
             * @description The order of the pin in the local FireFly database, which matches the order in which pins were delivered to FireFly by the blockchain connector event stream
             */
            sequence?: number;
            /** @description The blockchain signing key that submitted this transaction, as passed through to FireFly by the smart contract that emitted the blockchain event */
            signer?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Force a rewind of the event aggregator to a previous position, to re-evaluate (and possibly dispatch) that pin and others after it. Only accepts a sequence or batch ID for a currently undispatched pin */
  postPinsRewind: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
             */
            batch?: string;
            /**
             * Format: int64
             * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
             */
            sequence?: number;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * Format: uuid
           * @description The ID of the batch to which the event aggregator should rewind. Either sequence or batch must be specified
           */
          batch?: string;
          /**
           * Format: int64
           * @description The sequence of the pin to which the event aggregator should rewind. Either sequence or batch must be specified
           */
          sequence?: number;
        };
      };
    };
  };
  /** Gets the status of this namespace */
  getStatus: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Information about the multi-party system configured on this namespace */
            multiparty?: {
              /** @description Information about the multi-party smart contract configured for this namespace */
              contract?: {
                /** @description The currently active FireFly smart contract */
                active?: {
                  /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                  firstEvent?: string;
                  /** @description The index of this contract in the config file */
                  index?: number;
                  /** @description Additional info about the current status of the multi-party contract */
                  info?: {
                    /** @description The identifier for the final blockchain event received from this contract before termination */
                    finalEvent?: string;
                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                    subscription?: string;
                    /** @description The version of this multiparty contract */
                    version?: number;
                  };
                  /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                  location?: any;
                };
                /** @description Previously-terminated FireFly smart contracts */
                terminated?: {
                  /** @description A blockchain specific string, such as a block number, to start listening from. The special strings 'oldest' and 'newest' are supported by all blockchain connectors */
                  firstEvent?: string;
                  /** @description The index of this contract in the config file */
                  index?: number;
                  /** @description Additional info about the current status of the multi-party contract */
                  info?: {
                    /** @description The identifier for the final blockchain event received from this contract before termination */
                    finalEvent?: string;
                    /** @description The backend identifier of the subscription for the FireFly BatchPin contract */
                    subscription?: string;
                    /** @description The version of this multiparty contract */
                    version?: number;
                  };
                  /** @description A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel */
                  location?: any;
                }[];
              };
              /** @description Whether multi-party mode is enabled for this namespace */
              enabled?: boolean;
            };
            /** @description The namespace that this status applies to */
            namespace?: {
              /**
               * Format: date-time
               * @description The time the namespace was created
               */
              created?: string;
              /** @description A description of the namespace */
              description?: string;
              /** @description The local namespace name */
              name?: string;
              /** @description The shared namespace name within the multiparty network */
              networkName?: string;
            };
            /** @description Details of the local node */
            node?: {
              /**
               * Format: uuid
               * @description The UUID of the node, if registered
               */
              id?: string;
              /** @description The name of this node, as specified in the local configuration */
              name?: string;
              /** @description Whether the node has been successfully registered */
              registered?: boolean;
            };
            /** @description Details of the root organization identity registered for this namespace on the local node */
            org?: {
              /** @description The DID of the organization identity, if registered */
              did?: string;
              /**
               * Format: uuid
               * @description The UUID of the organization, if registered
               */
              id?: string;
              /** @description The name of the node operator organization, as specified in the local configuration */
              name?: string;
              /** @description Whether the organization has been successfully registered */
              registered?: boolean;
              /** @description Array of verifiers (blockchain keys) owned by this identity */
              verifiers?: {
                /**
                 * @description The type of the verifier
                 * @enum {string}
                 */
                type?:
                  | "ethereum_address"
                  | "tezos_address"
                  | "fabric_msp_id"
                  | "dx_peer_id";
                /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
                value?: string;
              }[];
            };
            /** @description Information about plugins configured on this namespace */
            plugins?: {
              /** @description The blockchain plugins on this namespace */
              blockchain?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The data exchange plugins on this namespace */
              dataExchange?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The database plugins on this namespace */
              database?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The event plugins on this namespace */
              events?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The identity plugins on this namespace */
              identity?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The shared storage plugins on this namespace */
              sharedStorage?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
              /** @description The token plugins on this namespace */
              tokens?: {
                /** @description The name of the plugin */
                name?: string;
                /** @description The type of the plugin */
                pluginType?: string;
              }[];
            };
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets the status of the batch manager */
  getStatusBatchManager: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description An array of currently active batch processors */
            processors?: {
              /** @description The type of dispatcher for this processor */
              dispatcher?: string;
              /** @description The name of the processor, which includes details of the attributes of message are allocated to this processor */
              name?: string;
              /** @description The flush status for this batch processor */
              status?: {
                /**
                 * Format: int64
                 * @description The average byte size of each batch
                 */
                averageBatchBytes?: number;
                /**
                 * Format: double
                 * @description The average number of data attachments included in each batch
                 */
                averageBatchData?: number;
                /**
                 * Format: double
                 * @description The average number of messages included in each batch
                 */
                averageBatchMessages?: number;
                /**
                 * Format: int64
                 * @description The average amount of time spent flushing each batch
                 */
                averageFlushTimeMS?: number;
                /** @description True if the batch flush is in a retry loop, due to errors being returned by the plugins */
                blocked?: boolean;
                /**
                 * Format: uuid
                 * @description If a flush is in progress, this is the UUID of the batch being flushed
                 */
                flushing?: string;
                /** @description The last error received by this batch processor while flushing */
                lastFlushError?: string;
                /**
                 * Format: date-time
                 * @description The time of the last flush
                 */
                lastFlushErrorTime?: string;
                /**
                 * Format: date-time
                 * @description The last time a flush was performed
                 */
                lastFlushStartTime?: string;
                /**
                 * Format: int64
                 * @description The total count of batches flushed by this processor since it started
                 */
                totalBatches?: number;
                /**
                 * Format: int64
                 * @description The total count of error flushed encountered by this processor since it started
                 */
                totalErrors?: number;
              };
            }[];
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of subscriptions */
  getSubscriptions: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        events?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        filters?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        options?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        transport?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Update an existing subscription */
  putSubscription: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Server-side filter to apply to events */
          filter?: {
            /** @description Deprecated: Please use 'message.author' instead */
            author?: string;
            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
            blockchainevent?: {
              /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
              listener?: string;
              /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
              name?: string;
            };
            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
            events?: string;
            /** @description Deprecated: Please use 'message.group' instead */
            group?: string;
            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
            message?: {
              /** @description Regular expression to apply to the message 'header.author' field */
              author?: string;
              /** @description Regular expression to apply to the message 'header.group' field */
              group?: string;
              /** @description Regular expression to apply to the message 'header.tag' field */
              tag?: string;
            };
            /** @description Deprecated: Please use 'message.tag' instead */
            tag?: string;
            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
            topic?: string;
            /** @description Deprecated: Please use 'topic' instead */
            topics?: string;
            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
            transaction?: {
              /** @description Regular expression to apply to the transaction 'type' field */
              type?: string;
            };
          };
          /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
          name?: string;
          /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
          namespace?: string;
          /** @description Subscription options */
          options?: {
            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
            batch?: boolean;
            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
            batchTimeout?: string;
            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
            fastack?: boolean;
            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
            firstEvent?: string;
            /** @description Webhooks only: Static headers to set on the webhook request */
            headers?: { [key: string]: string };
            /** @description Webhooks only: a set of options for HTTP */
            httpOptions?: {
              /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
              connectionTimeout?: string;
              /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
              expectContinueTimeout?: string;
              /** @description The max duration to hold a HTTP keepalive connection between calls */
              idleTimeout?: string;
              /** @description The max number of idle connections to hold pooled */
              maxIdleConns?: number;
              /** @description HTTP proxy URL to use for outbound requests to the webhook */
              proxyURL?: string;
              /** @description The max duration to hold a TLS handshake alive */
              requestTimeout?: string;
              /** @description The max duration to hold a TLS handshake alive */
              tlsHandshakeTimeout?: string;
            };
            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
            input?: {
              /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
              body?: string;
              /** @description A top-level property of the first data input, to use for headers */
              headers?: string;
              /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
              path?: string;
              /** @description A top-level property of the first data input, to use for query parameters */
              query?: string;
              /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
              replytx?: string;
            };
            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
            json?: boolean;
            /** @description Webhooks only: HTTP method to invoke. Default=POST */
            method?: string;
            /** @description Webhooks only: Static query params to set on the webhook request */
            query?: { [key: string]: string };
            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
            readAhead?: number;
            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
            reply?: boolean;
            /** @description Webhooks only: The tag to set on the reply message */
            replytag?: string;
            /** @description Webhooks only: The transaction type to set on the reply message */
            replytx?: string;
            /** @description Webhooks only: a set of options for retrying the webhook call */
            retry?: {
              /** @description Number of times to retry the webhook call in case of failure */
              count?: number;
              /** @description Enables retry on HTTP calls, defaults to false */
              enabled?: boolean;
              /** @description Initial delay between retries when we retry the webhook call */
              initialDelay?: string;
              /** @description Max delay between retries when we retry the webhookcall */
              maxDelay?: string;
            };
            /** @description The name of an existing TLS configuration associated to the namespace to use */
            tlsConfigName?: string;
            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
            url?: string;
            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
            withData?: boolean;
          };
          /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
          transport?: string;
        };
      };
    };
  };
  /** Creates a new subscription for an application to receive events from FireFly */
  postNewSubscription: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      201: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Server-side filter to apply to events */
          filter?: {
            /** @description Deprecated: Please use 'message.author' instead */
            author?: string;
            /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
            blockchainevent?: {
              /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
              listener?: string;
              /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
              name?: string;
            };
            /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
            events?: string;
            /** @description Deprecated: Please use 'message.group' instead */
            group?: string;
            /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
            message?: {
              /** @description Regular expression to apply to the message 'header.author' field */
              author?: string;
              /** @description Regular expression to apply to the message 'header.group' field */
              group?: string;
              /** @description Regular expression to apply to the message 'header.tag' field */
              tag?: string;
            };
            /** @description Deprecated: Please use 'message.tag' instead */
            tag?: string;
            /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
            topic?: string;
            /** @description Deprecated: Please use 'topic' instead */
            topics?: string;
            /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
            transaction?: {
              /** @description Regular expression to apply to the transaction 'type' field */
              type?: string;
            };
          };
          /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
          name?: string;
          /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
          namespace?: string;
          /** @description Subscription options */
          options?: {
            /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
            batch?: boolean;
            /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
            batchTimeout?: string;
            /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
            fastack?: boolean;
            /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
            firstEvent?: string;
            /** @description Webhooks only: Static headers to set on the webhook request */
            headers?: { [key: string]: string };
            /** @description Webhooks only: a set of options for HTTP */
            httpOptions?: {
              /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
              connectionTimeout?: string;
              /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
              expectContinueTimeout?: string;
              /** @description The max duration to hold a HTTP keepalive connection between calls */
              idleTimeout?: string;
              /** @description The max number of idle connections to hold pooled */
              maxIdleConns?: number;
              /** @description HTTP proxy URL to use for outbound requests to the webhook */
              proxyURL?: string;
              /** @description The max duration to hold a TLS handshake alive */
              requestTimeout?: string;
              /** @description The max duration to hold a TLS handshake alive */
              tlsHandshakeTimeout?: string;
            };
            /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
            input?: {
              /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
              body?: string;
              /** @description A top-level property of the first data input, to use for headers */
              headers?: string;
              /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
              path?: string;
              /** @description A top-level property of the first data input, to use for query parameters */
              query?: string;
              /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
              replytx?: string;
            };
            /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
            json?: boolean;
            /** @description Webhooks only: HTTP method to invoke. Default=POST */
            method?: string;
            /** @description Webhooks only: Static query params to set on the webhook request */
            query?: { [key: string]: string };
            /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
            readAhead?: number;
            /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
            reply?: boolean;
            /** @description Webhooks only: The tag to set on the reply message */
            replytag?: string;
            /** @description Webhooks only: The transaction type to set on the reply message */
            replytx?: string;
            /** @description Webhooks only: a set of options for retrying the webhook call */
            retry?: {
              /** @description Number of times to retry the webhook call in case of failure */
              count?: number;
              /** @description Enables retry on HTTP calls, defaults to false */
              enabled?: boolean;
              /** @description Initial delay between retries when we retry the webhook call */
              initialDelay?: string;
              /** @description Max delay between retries when we retry the webhookcall */
              maxDelay?: string;
            };
            /** @description The name of an existing TLS configuration associated to the namespace to use */
            tlsConfigName?: string;
            /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
            url?: string;
            /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
            withData?: boolean;
          };
          /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
          transport?: string;
        };
      };
    };
  };
  /** Gets a subscription by its ID */
  getSubscriptionByID: {
    parameters: {
      path: {
        /** The subscription ID */
        subid: string;
      };
      query: {
        /** When set, the API will return additional status information if available */
        fetchstatus?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description Creation time of the subscription
             */
            created?: string;
            /** @description Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection */
            ephemeral?: boolean;
            /** @description Server-side filter to apply to events */
            filter?: {
              /** @description Deprecated: Please use 'message.author' instead */
              author?: string;
              /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
              blockchainevent?: {
                /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                listener?: string;
                /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                name?: string;
              };
              /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
              events?: string;
              /** @description Deprecated: Please use 'message.group' instead */
              group?: string;
              /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
              message?: {
                /** @description Regular expression to apply to the message 'header.author' field */
                author?: string;
                /** @description Regular expression to apply to the message 'header.group' field */
                group?: string;
                /** @description Regular expression to apply to the message 'header.tag' field */
                tag?: string;
              };
              /** @description Deprecated: Please use 'message.tag' instead */
              tag?: string;
              /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
              topic?: string;
              /** @description Deprecated: Please use 'topic' instead */
              topics?: string;
              /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
              transaction?: {
                /** @description Regular expression to apply to the transaction 'type' field */
                type?: string;
              };
            };
            /**
             * Format: uuid
             * @description The UUID of the subscription
             */
            id?: string;
            /** @description The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances */
            name?: string;
            /** @description The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription */
            namespace?: string;
            /** @description Subscription options */
            options?: {
              /** @description Events are delivered in batches in an ordered array. The batch size is capped to the readAhead limit. The event payload is always an array even if there is a single event in the batch. Commonly used with Webhooks to allow events to be delivered and acknowledged in batches. */
              batch?: boolean;
              /** @description When batching is enabled, the optional timeout to send events even when the batch hasn't filled. */
              batchTimeout?: string;
              /** @description Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations */
              fastack?: boolean;
              /** @description Whether your application would like to receive events from the 'oldest' event emitted by your FireFly node (from the beginning of time), or the 'newest' event (from now), or a specific event sequence. Default is 'newest' */
              firstEvent?: string;
              /** @description Webhooks only: Static headers to set on the webhook request */
              headers?: { [key: string]: string };
              /** @description Webhooks only: a set of options for HTTP */
              httpOptions?: {
                /** @description The maximum amount of time that a connection is allowed to remain with no data transmitted. */
                connectionTimeout?: string;
                /** @description See [ExpectContinueTimeout in the Go docs](https://pkg.go.dev/net/http#Transport) */
                expectContinueTimeout?: string;
                /** @description The max duration to hold a HTTP keepalive connection between calls */
                idleTimeout?: string;
                /** @description The max number of idle connections to hold pooled */
                maxIdleConns?: number;
                /** @description HTTP proxy URL to use for outbound requests to the webhook */
                proxyURL?: string;
                /** @description The max duration to hold a TLS handshake alive */
                requestTimeout?: string;
                /** @description The max duration to hold a TLS handshake alive */
                tlsHandshakeTimeout?: string;
              };
              /** @description Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true */
              input?: {
                /** @description A top-level property of the first data input, to use for the request body. Default is the whole first body */
                body?: string;
                /** @description A top-level property of the first data input, to use for headers */
                headers?: string;
                /** @description A top-level property of the first data input, to use for a path to append with escaping to the webhook path */
                path?: string;
                /** @description A top-level property of the first data input, to use for query parameters */
                query?: string;
                /** @description A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) */
                replytx?: string;
              };
              /** @description Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type */
              json?: boolean;
              /** @description Webhooks only: HTTP method to invoke. Default=POST */
              method?: string;
              /** @description Webhooks only: Static query params to set on the webhook request */
              query?: { [key: string]: string };
              /** @description The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts */
              readAhead?: number;
              /** @description Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook */
              reply?: boolean;
              /** @description Webhooks only: The tag to set on the reply message */
              replytag?: string;
              /** @description Webhooks only: The transaction type to set on the reply message */
              replytx?: string;
              /** @description Webhooks only: a set of options for retrying the webhook call */
              retry?: {
                /** @description Number of times to retry the webhook call in case of failure */
                count?: number;
                /** @description Enables retry on HTTP calls, defaults to false */
                enabled?: boolean;
                /** @description Initial delay between retries when we retry the webhook call */
                initialDelay?: string;
                /** @description Max delay between retries when we retry the webhookcall */
                maxDelay?: string;
              };
              /** @description The name of an existing TLS configuration associated to the namespace to use */
              tlsConfigName?: string;
              /** @description Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config */
              url?: string;
              /** @description Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. */
              withData?: boolean;
            };
            /** @description The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) */
            transport?: string;
            /**
             * Format: date-time
             * @description Last time the subscription was updated
             */
            updated?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Deletes a subscription */
  deleteSubscription: {
    parameters: {
      path: {
        /** The subscription ID */
        subid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of token accounts */
  getTokenAccounts: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain signing identity this balance applies to */
            key?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of token pools that contain a given token account key */
  getTokenAccountPools: {
    parameters: {
      path: {
        /** The key for the token account. The exact format may vary based on the token connector use */
        key: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID the token pool this balance entry applies to
             */
            pool?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of token approvals */
  getTokenApprovals: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        active?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        approved?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainevent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        localid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        messagehash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        operator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        protocolid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        subject?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
            active?: boolean;
            /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
            approved?: boolean;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the token approval
             */
            created?: string;
            /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token approval, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the approval, which must match the namespace of the token pool */
            namespace?: string;
            /** @description The blockchain identity that is granted the approval */
            operator?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this approval applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
            subject?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a token approval */
  postTokenApproval: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
            active?: boolean;
            /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
            approved?: boolean;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the token approval
             */
            created?: string;
            /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token approval, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the approval, which must match the namespace of the token pool */
            namespace?: string;
            /** @description The blockchain identity that is granted the approval */
            operator?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this approval applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
            subject?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description Indicates if this approval is currently active (only one approval can be active per subject) */
            active?: boolean;
            /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
            approved?: boolean;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the token approval
             */
            created?: string;
            /** @description Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token approval, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this approval using the data field of the approval in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the approval, which must match the namespace of the token pool */
            namespace?: string;
            /** @description The blockchain identity that is granted the approval */
            operator?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this approval applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description A string identifying the parties and entities in the scope of this approval, as provided by the token connector */
            subject?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) */
          approved?: boolean;
          /** @description Input only field, with token connector specific configuration of the approval.  See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the approval, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the approval */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The blockchain identity that is granted the approval */
          operator?: string;
          /**
           * Format: uuid
           * @description The UUID the token pool this approval applies to
           */
          pool?: string;
        };
      };
    };
  };
  /** Gets a list of token balances */
  getTokenBalances: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        balance?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tokenindex?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        updated?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        uri?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The numeric balance. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when interpreting the balance. For example, with 18 decimals a fractional balance of 10.234 will be returned as 10,234,000,000,000,000,000 */
            balance?: string;
            /** @description The token connector that is responsible for the token pool of this balance entry */
            connector?: string;
            /** @description The blockchain signing identity this balance applies to */
            key?: string;
            /** @description The namespace of the token pool for this balance entry */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this balance entry applies to
             */
            pool?: string;
            /** @description The index of the token within the pool that this balance applies to */
            tokenIndex?: string;
            /**
             * Format: date-time
             * @description The last time the balance was updated by applying a transfer event
             */
            updated?: string;
            /** @description The URI of the token this balance entry applies to */
            uri?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Burns some tokens */
  postTokenBurn: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
          amount?: string;
          /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description The source account for the transfer. On input defaults to the value of 'key' */
          from?: string;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The name or UUID of a token pool */
          pool?: string;
          /** @description The index of the token within the pool that this transfer applies to */
          tokenIndex?: string;
          /** @description The URI of the token this transfer applies to */
          uri?: string;
        };
      };
    };
  };
  /** Gets the list of token connectors currently in use */
  getTokenConnectors: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The name of the token connector, as configured in the FireFly core configuration file */
            name?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Mints some tokens */
  postTokenMint: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
          amount?: string;
          /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The name or UUID of a token pool */
          pool?: string;
          /** @description The target account for the transfer. On input defaults to the value of 'key' */
          to?: string;
          /** @description The index of the token within the pool that this transfer applies to */
          tokenIndex?: string;
          /** @description The URI of the token this transfer applies to */
          uri?: string;
        };
      };
    };
  };
  /** Gets a list of token pools */
  getTokenPools: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        active?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        decimals?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interface?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        interfaceformat?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        locator?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        name?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        networkname?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        published?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        standard?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        symbol?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Creates a new token pool */
  postTokenPool: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
        /** When true the definition will be published to all other members of the multiparty network */
        publish?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Input only field, with token connector specific configuration of the pool, such as an existing Ethereum address and block number to used to index the pool. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
          connector?: string;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
          interface?: {
            /**
             * Format: uuid
             * @description The UUID of the FireFly interface
             */
            id?: string;
            /** @description The name of the FireFly interface */
            name?: string;
            /** @description The version of the FireFly interface */
            version?: string;
          };
          /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
          key?: string;
          /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
          name?: string;
          /** @description The published name of the token pool within the multiparty network */
          networkName?: string;
          /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
          symbol?: string;
          /**
           * @description The type of token the pool contains, such as fungible/non-fungible
           * @enum {string}
           */
          type?: "fungible" | "nonfungible";
        };
      };
    };
  };
  /** Gets a token pool by its name or its ID */
  getTokenPoolByNameOrID: {
    parameters: {
      path: {
        /** The token pool name or ID */
        nameOrId: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      default: unknown;
    };
  };
  /** Delete a token pool */
  deleteTokenPool: {
    parameters: {
      path: {
        /** The token pool name or ID */
        nameOrId: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      204: {
        content: {
          "application/json": unknown;
        };
      };
      default: unknown;
    };
  };
  /** Publish a token pool to all other members of the multiparty network */
  postTokenPoolPublish: {
    parameters: {
      path: {
        /** The token pool name or ID */
        nameOrId: string;
      };
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description Indicates whether the pool has been successfully activated with the token connector */
            active?: boolean;
            /** @description The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the pool
             */
            created?: string;
            /** @description Number of decimal places that this token has */
            decimals?: number;
            /**
             * Format: uuid
             * @description The UUID of the token pool
             */
            id?: string;
            /** @description Token connector specific information about the pool. See your chosen token connector documentation for details */
            info?: { [key: string]: any };
            /** @description A reference to an existing FFI, containing pre-registered type information for the token contract */
            interface?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly interface
               */
              id?: string;
              /** @description The name of the FireFly interface */
              name?: string;
              /** @description The version of the FireFly interface */
              version?: string;
            };
            /**
             * @description The interface encoding format supported by the connector for this token pool
             * @enum {string}
             */
            interfaceFormat?: "abi" | "ffi";
            /** @description The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain */
            key?: string;
            /** @description A unique identifier for the pool, as provided by the token connector */
            locator?: string;
            /**
             * Format: uuid
             * @description The UUID of the broadcast message used to inform the network about this pool
             */
            message?: string;
            /** @description The method definitions resolved by the token connector to be used by each token operation */
            methods?: any;
            /** @description The name of the token pool. Note the name is not validated against the description of the token on the blockchain */
            name?: string;
            /** @description The namespace for the token pool */
            namespace?: string;
            /** @description The published name of the token pool within the multiparty network */
            networkName?: string;
            /** @description Indicates if the token pool is published to other members of the multiparty network */
            published?: boolean;
            /** @description The ERC standard the token pool conforms to, as reported by the token connector */
            standard?: string;
            /** @description The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information */
            symbol?: string;
            /** @description Reference to the FireFly transaction used to create and broadcast this pool to the network */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of token the pool contains, such as fungible/non-fungible
             * @enum {string}
             */
            type?: "fungible" | "nonfungible";
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description An optional name to be used for publishing this definition to the multiparty network, which may differ from the local name */
          networkName?: string;
        };
      };
    };
  };
  /** Gets a list of token transfers */
  getTokenTransfers: {
    parameters: {
      query: {
        /** The sending or receiving token account for a token transfer */
        fromOrTo?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        amount?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainevent?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        connector?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        from?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        key?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        localid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        message?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        messagehash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        pool?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        protocolid?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        to?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        tokenindex?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.id"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        "tx.type"?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        uri?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Transfers some tokens */
  postTokenTransfer: {
    parameters: {
      query: {
        /** When true the HTTP request blocks until the message is confirmed */
        confirm?: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      /** Success */
      202: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
          amount?: string;
          /** @description Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details */
          config?: { [key: string]: any };
          /** @description The source account for the transfer. On input defaults to the value of 'key' */
          from?: string;
          /** @description An optional identifier to allow idempotent submission of requests. Stored on the transaction uniquely within a namespace */
          idempotencyKey?: string;
          /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
          key?: string;
          /** @description You can specify a message to correlate with the transfer, which can be of type broadcast or private. Your chosen token connector and on-chain smart contract must support on-chain/off-chain correlation by taking a `data` input on the transfer */
          message?: {
            /** @description For input allows you to specify data in-line in the message, that will be turned into data attachments. For output when fetchdata is used on API calls, includes the in-line data payloads of all data attachments */
            data?: {
              /** @description The optional datatype to use for validation of the in-line data */
              datatype?: {
                /** @description The name of the datatype */
                name?: string;
                /** @description The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 */
                version?: string;
              };
              /**
               * Format: uuid
               * @description The UUID of the referenced data resource
               */
              id?: string;
              /** @description The data validator type to use for in-line data */
              validator?: string;
              /** @description The in-line value for the data. Can be any JSON type - object, array, string, number or boolean */
              value?: any;
            }[];
            /** @description Allows you to specify details of the private group of recipients in-line in the message. Alternative to using the header.group to specify the hash of a group that has been previously resolved */
            group?: {
              /** @description An array of members of the group. If no identities local to the sending node are included, then the organization owner of the local node is added automatically */
              members?: {
                /** @description The DID of the group member. On input can be a UUID or org name, and will be resolved to a DID */
                identity?: string;
                /** @description The UUID of the node that will receive a copy of the off-chain message for the identity. The first applicable node for the identity will be picked automatically on input if not specified */
                node?: string;
              }[];
              /** @description Optional name for the group. Allows you to have multiple separate groups with the same list of participants */
              name?: string;
            };
            /** @description The message header contains all fields that are used to build the message hash */
            header?: {
              /** @description The DID of identity of the submitter */
              author?: string;
              /**
               * Format: uuid
               * @description The correlation ID of the message. Set this when a message is a response to another message
               */
              cid?: string;
              /**
               * Format: byte
               * @description Private messages only - the identifier hash of the privacy group. Derived from the name and member list of the group
               */
              group?: string;
              /** @description The on-chain signing key used to sign the transaction */
              key?: string;
              /** @description The message tag indicates the purpose of the message to the applications that process it */
              tag?: string;
              /** @description A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged */
              topics?: string[];
              /**
               * @description The type of transaction used to order/deliver this message
               * @enum {string}
               */
              txtype?:
                | "none"
                | "unpinned"
                | "batch_pin"
                | "network_action"
                | "token_pool"
                | "token_transfer"
                | "contract_deploy"
                | "contract_invoke"
                | "contract_invoke_pin"
                | "token_approval"
                | "data_publish";
              /**
               * @description The type of the message
               * @enum {string}
               */
              type?:
                | "definition"
                | "broadcast"
                | "private"
                | "groupinit"
                | "transfer_broadcast"
                | "transfer_private"
                | "approval_broadcast"
                | "approval_private";
            };
            /** @description An optional unique identifier for a message. Cannot be duplicated within a namespace, thus allowing idempotent submission of messages to the API. Local only - not transferred when the message is sent to other members of the network */
            idempotencyKey?: string;
          };
          /** @description The name or UUID of a token pool */
          pool?: string;
          /** @description The target account for the transfer. On input defaults to the value of 'key' */
          to?: string;
          /** @description The index of the token within the pool that this transfer applies to */
          tokenIndex?: string;
          /** @description The URI of the token this transfer applies to */
          uri?: string;
        };
      };
    };
  };
  /** Gets a token transfer by its ID */
  getTokenTransferByID: {
    parameters: {
      path: {
        /** The token transfer ID */
        transferId: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 */
            amount?: string;
            /**
             * Format: uuid
             * @description The UUID of the blockchain event
             */
            blockchainEvent?: string;
            /** @description The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured */
            connector?: string;
            /**
             * Format: date-time
             * @description The creation time of the transfer
             */
            created?: string;
            /** @description The source account for the transfer. On input defaults to the value of 'key' */
            from?: string;
            /** @description The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node */
            key?: string;
            /**
             * Format: uuid
             * @description The UUID of this token transfer, in the local FireFly node
             */
            localId?: string;
            /**
             * Format: uuid
             * @description The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            message?: string;
            /**
             * Format: byte
             * @description The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector
             */
            messageHash?: string;
            /** @description The namespace for the transfer, which must match the namespace of the token pool */
            namespace?: string;
            /**
             * Format: uuid
             * @description The UUID the token pool this transfer applies to
             */
            pool?: string;
            /** @description An alphanumerically sortable string that represents this event uniquely with respect to the blockchain */
            protocolId?: string;
            /** @description The target account for the transfer. On input defaults to the value of 'key' */
            to?: string;
            /** @description The index of the token within the pool that this transfer applies to */
            tokenIndex?: string;
            /** @description If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) */
            tx?: {
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
            /**
             * @description The type of transfer such as mint/burn/transfer
             * @enum {string}
             */
            type?: "mint" | "burn" | "transfer";
            /** @description The URI of the token this transfer applies to */
            uri?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of transactions */
  getTxns: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainids?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
            blockchainIds?: string[];
            /**
             * Format: date-time
             * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction
             */
            id?: string;
            /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
            idempotencyKey?: string;
            /** @description The namespace of the FireFly transaction */
            namespace?: string;
            /**
             * @description The type of the FireFly transaction
             * @enum {string}
             */
            type?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a transaction by its ID */
  getTxnByID: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        blockchainids?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        id?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        idempotencykey?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions */
            blockchainIds?: string[];
            /**
             * Format: date-time
             * @description The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction
             */
            created?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction
             */
            id?: string;
            /** @description An optional unique identifier for a transaction. Cannot be duplicated within a namespace, thus allowing idempotent submission of transactions to the API */
            idempotencyKey?: string;
            /** @description The namespace of the FireFly transaction */
            namespace?: string;
            /**
             * @description The type of the FireFly transaction
             * @enum {string}
             */
            type?:
              | "none"
              | "unpinned"
              | "batch_pin"
              | "network_action"
              | "token_pool"
              | "token_transfer"
              | "contract_deploy"
              | "contract_invoke"
              | "contract_invoke_pin"
              | "token_approval"
              | "data_publish";
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list blockchain events for a specific transaction */
  getTxnBlockchainEvents: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: uuid
             * @description The UUID assigned to the event by FireFly
             */
            id?: string;
            /** @description Detailed blockchain specific information about the event, as generated by the blockchain connector */
            info?: { [key: string]: any };
            /**
             * Format: uuid
             * @description The UUID of the listener that detected this event, or nil for built-in events in the system namespace
             */
            listener?: string;
            /** @description The name of the event in the blockchain smart contract */
            name?: string;
            /** @description The namespace of the listener that detected this blockchain event */
            namespace?: string;
            /** @description The data output by the event, parsed to JSON according to the interface of the smart contract */
            output?: { [key: string]: any };
            /** @description An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) */
            protocolId?: string;
            /** @description The blockchain plugin or token service that detected the event */
            source?: string;
            /**
             * Format: date-time
             * @description The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors
             */
            timestamp?: string;
            /** @description If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction */
            tx?: {
              /** @description The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain */
              blockchainId?: string;
              /**
               * Format: uuid
               * @description The UUID of the FireFly transaction
               */
              id?: string;
              /** @description The type of the FireFly transaction */
              type?: string;
            };
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of operations in a specific transaction */
  getTxnOps: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time the operation was created
             */
            created?: string;
            /** @description Any error reported back from the plugin for this operation */
            error?: string;
            /**
             * Format: uuid
             * @description The UUID of the operation
             */
            id?: string;
            /** @description The input to this operation */
            input?: { [key: string]: any };
            /** @description The namespace of the operation */
            namespace?: string;
            /** @description Any output reported back from the plugin for this operation */
            output?: { [key: string]: any };
            /** @description The plugin responsible for performing the operation */
            plugin?: string;
            /**
             * Format: uuid
             * @description If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried
             */
            retry?: string;
            /** @description The current status of the operation */
            status?: string;
            /**
             * Format: uuid
             * @description The UUID of the FireFly transaction the operation is part of
             */
            tx?: string;
            /**
             * @description The type of the operation
             * @enum {string}
             */
            type?:
              | "blockchain_pin_batch"
              | "blockchain_network_action"
              | "blockchain_deploy"
              | "blockchain_invoke"
              | "sharedstorage_upload_batch"
              | "sharedstorage_upload_blob"
              | "sharedstorage_upload_value"
              | "sharedstorage_download_batch"
              | "sharedstorage_download_blob"
              | "dataexchange_send_batch"
              | "dataexchange_send_blob"
              | "token_create_pool"
              | "token_activate_pool"
              | "token_transfer"
              | "token_approval";
            /**
             * Format: date-time
             * @description The last update time of the operation
             */
            updated?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets the status of a transaction */
  getTxnStatus: {
    parameters: {
      path: {
        /** The transaction ID */
        txnid: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description A set of records describing the activities within the transaction known by the local FireFly node */
            details?: {
              /** @description If an error occurred related to the detail entry, it is included here */
              error?: string;
              /**
               * Format: uuid
               * @description The UUID of the entry referenced by this detail. The type of this record can be inferred from the entry type
               */
              id?: string;
              /** @description Output details for this entry */
              info?: { [key: string]: any };
              /** @description The status of the detail record. Cases where an event is required for completion, but has not arrived yet are marked with a 'pending' record */
              status?: string;
              /** @description A sub-type, such as an operation type, or an event type */
              subtype?: string;
              /**
               * Format: date-time
               * @description The time relevant to when the record was updated, such as the time an event was created, or the last update time of an operation
               */
              timestamp?: string;
              /** @description The type of the transaction status detail record */
              type?: string;
            }[];
            /** @description The overall computed status of the transaction, after analyzing the details during the API call */
            status?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Gets a list of verifiers */
  getVerifiers: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
      query: {
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        created?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        hash?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        identity?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        type?: string;
        /** Data filter field. Prefixes supported: > >= < <= @ ^ ! !@ !^ */
        value?: string;
        /** Sort field. For multi-field sort use comma separated values (or multiple query values) with '-' prefix for descending */
        sort?: string;
        /** Ascending sort order (overrides all fields in a multi-field sort) */
        ascending?: string;
        /** Descending sort order (overrides all fields in a multi-field sort) */
        descending?: string;
        /** The number of records to skip (max: 1,000). Unsuitable for bulk operations */
        skip?: string;
        /** The maximum number of records to return (max: 1,000) */
        limit?: string;
        /** Return a total count as well as items (adds extra database processing) */
        count?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time this verifier was created on this node
             */
            created?: string;
            /**
             * Format: byte
             * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity that has claimed this verifier
             */
            identity?: string;
            /** @description The namespace of the verifier */
            namespace?: string;
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          }[];
        };
      };
      default: unknown;
    };
  };
  /** Gets a verifier by its hash */
  getVerifierByID: {
    parameters: {
      path: {
        /** The hash of the verifier */
        hash: string;
      };
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * Format: date-time
             * @description The time this verifier was created on this node
             */
            created?: string;
            /**
             * Format: byte
             * @description Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network
             */
            hash?: string;
            /**
             * Format: uuid
             * @description The UUID of the parent identity that has claimed this verifier
             */
            identity?: string;
            /** @description The namespace of the verifier */
            namespace?: string;
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          };
        };
      };
      default: unknown;
    };
  };
  /** Resolves an input key to a signing key */
  postVerifiersResolve: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /**
             * @description The type of the verifier
             * @enum {string}
             */
            type?:
              | "ethereum_address"
              | "tezos_address"
              | "fabric_msp_id"
              | "dx_peer_id";
            /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
            value?: string;
          };
        };
      };
      default: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The type of the verifier
           * @enum {string}
           */
          type?:
            | "ethereum_address"
            | "tezos_address"
            | "fabric_msp_id"
            | "dx_peer_id";
          /** @description The verifier string, such as an Ethereum address, or Fabric MSP identifier */
          value?: string;
        };
      };
    };
  };
  /** Gets a list of the current WebSocket connections to this node */
  getWebSockets: {
    parameters: {
      header: {
        /** Server-side request timeout (milliseconds, or set a custom suffix like 10s) */
        "Request-Timeout"?: string;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": {
            /** @description List of currently active websocket client connections */
            connections?: {
              /** @description The unique ID assigned to this client connection */
              id?: string;
              /** @description The remote address of the connected client (if available) */
              remoteAddress?: string;
              /** @description List of subscriptions currently started by this client */
              subscriptions?: {
                /** @description Indicates whether the subscription is ephemeral (vs durable) */
                ephemeral?: boolean;
                /** @description The subscription filter specification */
                filter?: {
                  /** @description Deprecated: Please use 'message.author' instead */
                  author?: string;
                  /** @description Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored */
                  blockchainevent?: {
                    /** @description Regular expression to apply to the blockchain event 'listener' field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the 'topic' field of blockchain event listeners, and use a topic filter on your subscriptions */
                    listener?: string;
                    /** @description Regular expression to apply to the blockchain event 'name' field, which is the name of the event in the underlying blockchain smart contract */
                    name?: string;
                  };
                  /** @description Regular expression to apply to the event type, to subscribe to a subset of event types */
                  events?: string;
                  /** @description Deprecated: Please use 'message.group' instead */
                  group?: string;
                  /** @description Filters specific to message events. If an event is not a message event, these filters are ignored */
                  message?: {
                    /** @description Regular expression to apply to the message 'header.author' field */
                    author?: string;
                    /** @description Regular expression to apply to the message 'header.group' field */
                    group?: string;
                    /** @description Regular expression to apply to the message 'header.tag' field */
                    tag?: string;
                  };
                  /** @description Deprecated: Please use 'message.tag' instead */
                  tag?: string;
                  /** @description Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic */
                  topic?: string;
                  /** @description Deprecated: Please use 'topic' instead */
                  topics?: string;
                  /** @description Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored */
                  transaction?: {
                    /** @description Regular expression to apply to the transaction 'type' field */
                    type?: string;
                  };
                };
                /** @description The subscription name (for durable subscriptions only) */
                name?: string;
                /** @description The subscription namespace */
                namespace?: string;
                /**
                 * Format: date-time
                 * @description The time the subscription started (reset on dynamic namespace reload)
                 */
                startTime?: string;
              }[];
              /** @description The user agent of the connected client (if available) */
              userAgent?: string;
            }[];
            /** @description Indicates whether the websockets plugin is enabled */
            enabled?: boolean;
          };
        };
      };
      default: unknown;
    };
  };
}

export interface external {}
